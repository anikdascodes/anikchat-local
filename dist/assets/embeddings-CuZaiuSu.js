const __vite__mapDeps=(i,m=__vite__mapDeps,d=(m.f||(m.f=["assets/transformers-CZ2y5aXR.js","assets/react-vendor-LRKn6Gx2.js"])))=>i.map(i=>d[i]);
import{_ as V}from"./syntax-C7EQ9WnS.js";import"./react-vendor-LRKn6Gx2.js";import"./markdown-Dw-9lzaj.js";import"./ui-vendor-ByqAr3tj.js";const F=typeof performance=="object"&&performance&&typeof performance.now=="function"?performance:Date,G=new Set,D=typeof process=="object"&&process?process:{},N=(a,t,e,i)=>{typeof D.emitWarning=="function"?D.emitWarning(a,t,e,i):console.error(`[${e}] ${t}: ${a}`)};let R=globalThis.AbortController,U=globalThis.AbortSignal;if(typeof R>"u"){U=class{onabort;_onabort=[];reason;aborted=!1;addEventListener(i,s){this._onabort.push(s)}},R=class{constructor(){t()}signal=new U;abort(i){if(!this.signal.aborted){this.signal.reason=i,this.signal.aborted=!0;for(const s of this.signal._onabort)s(i);this.signal.onabort?.(i)}}};let a=D.env?.LRU_CACHE_IGNORE_AC_WARNING!=="1";const t=()=>{a&&(a=!1,N("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",t))}}const B=a=>!G.has(a),A=a=>a&&a===Math.floor(a)&&a>0&&isFinite(a),P=a=>A(a)?a<=Math.pow(2,8)?Uint8Array:a<=Math.pow(2,16)?Uint16Array:a<=Math.pow(2,32)?Uint32Array:a<=Number.MAX_SAFE_INTEGER?z:null:null;class z extends Array{constructor(t){super(t),this.fill(0)}}class E{heap;length;static#a=!1;static create(t){const e=P(t);if(!e)return[];E.#a=!0;const i=new E(t,e);return E.#a=!1,i}constructor(t,e){if(!E.#a)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new e(t),this.length=0}push(t){this.heap[this.length++]=t}pop(){return this.heap[--this.length]}}class x{#a;#c;#p;#w;#R;#W;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#n;#_;#s;#i;#t;#l;#u;#o;#h;#m;#r;#S;#b;#d;#y;#O;#f;static unsafeExposeInternals(t){return{starts:t.#b,ttls:t.#d,sizes:t.#S,keyMap:t.#s,keyList:t.#i,valList:t.#t,next:t.#l,prev:t.#u,get head(){return t.#o},get tail(){return t.#h},free:t.#m,isBackgroundFetch:e=>t.#e(e),backgroundFetch:(e,i,s,n)=>t.#x(e,i,s,n),moveToTail:e=>t.#C(e),indexes:e=>t.#A(e),rindexes:e=>t.#v(e),isStale:e=>t.#g(e)}}get max(){return this.#a}get maxSize(){return this.#c}get calculatedSize(){return this.#_}get size(){return this.#n}get fetchMethod(){return this.#R}get memoMethod(){return this.#W}get dispose(){return this.#p}get disposeAfter(){return this.#w}constructor(t){const{max:e=0,ttl:i,ttlResolution:s=1,ttlAutopurge:n,updateAgeOnGet:h,updateAgeOnHas:o,allowStale:r,dispose:g,disposeAfter:S,noDisposeOnSet:f,noUpdateTTL:u,maxSize:c=0,maxEntrySize:v=0,sizeCalculation:d,fetchMethod:_,memoMethod:l,noDeleteOnFetchRejection:w,noDeleteOnStaleGet:b,allowStaleOnFetchRejection:p,allowStaleOnFetchAbort:m,ignoreFetchAbort:O}=t;if(e!==0&&!A(e))throw new TypeError("max option must be a nonnegative integer");const y=e?P(e):Array;if(!y)throw new Error("invalid max value: "+e);if(this.#a=e,this.#c=c,this.maxEntrySize=v||this.#c,this.sizeCalculation=d,this.sizeCalculation){if(!this.#c&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if(typeof this.sizeCalculation!="function")throw new TypeError("sizeCalculation set to non-function")}if(l!==void 0&&typeof l!="function")throw new TypeError("memoMethod must be a function if defined");if(this.#W=l,_!==void 0&&typeof _!="function")throw new TypeError("fetchMethod must be a function if specified");if(this.#R=_,this.#O=!!_,this.#s=new Map,this.#i=new Array(e).fill(void 0),this.#t=new Array(e).fill(void 0),this.#l=new y(e),this.#u=new y(e),this.#o=0,this.#h=0,this.#m=E.create(e),this.#n=0,this.#_=0,typeof g=="function"&&(this.#p=g),typeof S=="function"?(this.#w=S,this.#r=[]):(this.#w=void 0,this.#r=void 0),this.#y=!!this.#p,this.#f=!!this.#w,this.noDisposeOnSet=!!f,this.noUpdateTTL=!!u,this.noDeleteOnFetchRejection=!!w,this.allowStaleOnFetchRejection=!!p,this.allowStaleOnFetchAbort=!!m,this.ignoreFetchAbort=!!O,this.maxEntrySize!==0){if(this.#c!==0&&!A(this.#c))throw new TypeError("maxSize must be a positive integer if specified");if(!A(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#j()}if(this.allowStale=!!r,this.noDeleteOnStaleGet=!!b,this.updateAgeOnGet=!!h,this.updateAgeOnHas=!!o,this.ttlResolution=A(s)||s===0?s:1,this.ttlAutopurge=!!n,this.ttl=i||0,this.ttl){if(!A(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#M()}if(this.#a===0&&this.ttl===0&&this.#c===0)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#a&&!this.#c){const T="LRU_CACHE_UNBOUNDED";B(T)&&(G.add(T),N("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",T,x))}}getRemainingTTL(t){return this.#s.has(t)?1/0:0}#M(){const t=new z(this.#a),e=new z(this.#a);this.#d=t,this.#b=e,this.#U=(n,h,o=F.now())=>{if(e[n]=h!==0?o:0,t[n]=h,h!==0&&this.ttlAutopurge){const r=setTimeout(()=>{this.#g(n)&&this.#F(this.#i[n],"expire")},h+1);r.unref&&r.unref()}},this.#T=n=>{e[n]=t[n]!==0?F.now():0},this.#E=(n,h)=>{if(t[h]){const o=t[h],r=e[h];if(!o||!r)return;n.ttl=o,n.start=r,n.now=i||s();const g=n.now-r;n.remainingTTL=o-g}};let i=0;const s=()=>{const n=F.now();if(this.ttlResolution>0){i=n;const h=setTimeout(()=>i=0,this.ttlResolution);h.unref&&h.unref()}return n};this.getRemainingTTL=n=>{const h=this.#s.get(n);if(h===void 0)return 0;const o=t[h],r=e[h];if(!o||!r)return 1/0;const g=(i||s())-r;return o-g},this.#g=n=>{const h=e[n],o=t[n];return!!o&&!!h&&(i||s())-h>o}}#T=()=>{};#E=()=>{};#U=()=>{};#g=()=>!1;#j(){const t=new z(this.#a);this.#_=0,this.#S=t,this.#z=e=>{this.#_-=t[e],t[e]=0},this.#I=(e,i,s,n)=>{if(this.#e(i))return 0;if(!A(s))if(n){if(typeof n!="function")throw new TypeError("sizeCalculation must be a function");if(s=n(i,e),!A(s))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}else throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");return s},this.#D=(e,i,s)=>{if(t[e]=i,this.#c){const n=this.#c-t[e];for(;this.#_>n;)this.#L(!0)}this.#_+=t[e],s&&(s.entrySize=i,s.totalCalculatedSize=this.#_)}}#z=t=>{};#D=(t,e,i)=>{};#I=(t,e,i,s)=>{if(i||s)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#A({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#h;!(!this.#G(e)||((t||!this.#g(e))&&(yield e),e===this.#o));)e=this.#u[e]}*#v({allowStale:t=this.allowStale}={}){if(this.#n)for(let e=this.#o;!(!this.#G(e)||((t||!this.#g(e))&&(yield e),e===this.#h));)e=this.#l[e]}#G(t){return t!==void 0&&this.#s.get(this.#i[t])===t}*entries(){for(const t of this.#A())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*rentries(){for(const t of this.#v())this.#t[t]!==void 0&&this.#i[t]!==void 0&&!this.#e(this.#t[t])&&(yield[this.#i[t],this.#t[t]])}*keys(){for(const t of this.#A()){const e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*rkeys(){for(const t of this.#v()){const e=this.#i[t];e!==void 0&&!this.#e(this.#t[t])&&(yield e)}}*values(){for(const t of this.#A())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}*rvalues(){for(const t of this.#v())this.#t[t]!==void 0&&!this.#e(this.#t[t])&&(yield this.#t[t])}[Symbol.iterator](){return this.entries()}[Symbol.toStringTag]="LRUCache";find(t,e={}){for(const i of this.#A()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;if(n!==void 0&&t(n,this.#i[i],this))return this.get(this.#i[i],e)}}forEach(t,e=this){for(const i of this.#A()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}rforEach(t,e=this){for(const i of this.#v()){const s=this.#t[i],n=this.#e(s)?s.__staleWhileFetching:s;n!==void 0&&t.call(e,n,this.#i[i],this)}}purgeStale(){let t=!1;for(const e of this.#v({allowStale:!0}))this.#g(e)&&(this.#F(this.#i[e],"expire"),t=!0);return t}info(t){const e=this.#s.get(t);if(e===void 0)return;const i=this.#t[e],s=this.#e(i)?i.__staleWhileFetching:i;if(s===void 0)return;const n={value:s};if(this.#d&&this.#b){const h=this.#d[e],o=this.#b[e];if(h&&o){const r=h-(F.now()-o);n.ttl=r,n.start=Date.now()}}return this.#S&&(n.size=this.#S[e]),n}dump(){const t=[];for(const e of this.#A({allowStale:!0})){const i=this.#i[e],s=this.#t[e],n=this.#e(s)?s.__staleWhileFetching:s;if(n===void 0||i===void 0)continue;const h={value:n};if(this.#d&&this.#b){h.ttl=this.#d[e];const o=F.now()-this.#b[e];h.start=Math.floor(Date.now()-o)}this.#S&&(h.size=this.#S[e]),t.unshift([i,h])}return t}load(t){this.clear();for(const[e,i]of t){if(i.start){const s=Date.now()-i.start;i.start=F.now()-s}this.set(e,i.value,i)}}set(t,e,i={}){if(e===void 0)return this.delete(t),this;const{ttl:s=this.ttl,start:n,noDisposeOnSet:h=this.noDisposeOnSet,sizeCalculation:o=this.sizeCalculation,status:r}=i;let{noUpdateTTL:g=this.noUpdateTTL}=i;const S=this.#I(t,e,i.size||0,o);if(this.maxEntrySize&&S>this.maxEntrySize)return r&&(r.set="miss",r.maxEntrySizeExceeded=!0),this.#F(t,"set"),this;let f=this.#n===0?void 0:this.#s.get(t);if(f===void 0)f=this.#n===0?this.#h:this.#m.length!==0?this.#m.pop():this.#n===this.#a?this.#L(!1):this.#n,this.#i[f]=t,this.#t[f]=e,this.#s.set(t,f),this.#l[this.#h]=f,this.#u[f]=this.#h,this.#h=f,this.#n++,this.#D(f,S,r),r&&(r.set="add"),g=!1;else{this.#C(f);const u=this.#t[f];if(e!==u){if(this.#O&&this.#e(u)){u.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:c}=u;c!==void 0&&!h&&(this.#y&&this.#p?.(c,t,"set"),this.#f&&this.#r?.push([c,t,"set"]))}else h||(this.#y&&this.#p?.(u,t,"set"),this.#f&&this.#r?.push([u,t,"set"]));if(this.#z(f),this.#D(f,S,r),this.#t[f]=e,r){r.set="replace";const c=u&&this.#e(u)?u.__staleWhileFetching:u;c!==void 0&&(r.oldValue=c)}}else r&&(r.set="update")}if(s!==0&&!this.#d&&this.#M(),this.#d&&(g||this.#U(f,s,n),r&&this.#E(r,f)),!h&&this.#f&&this.#r){const u=this.#r;let c;for(;c=u?.shift();)this.#w?.(...c)}return this}pop(){try{for(;this.#n;){const t=this.#t[this.#o];if(this.#L(!0),this.#e(t)){if(t.__staleWhileFetching)return t.__staleWhileFetching}else if(t!==void 0)return t}}finally{if(this.#f&&this.#r){const t=this.#r;let e;for(;e=t?.shift();)this.#w?.(...e)}}}#L(t){const e=this.#o,i=this.#i[e],s=this.#t[e];return this.#O&&this.#e(s)?s.__abortController.abort(new Error("evicted")):(this.#y||this.#f)&&(this.#y&&this.#p?.(s,i,"evict"),this.#f&&this.#r?.push([s,i,"evict"])),this.#z(e),t&&(this.#i[e]=void 0,this.#t[e]=void 0,this.#m.push(e)),this.#n===1?(this.#o=this.#h=0,this.#m.length=0):this.#o=this.#l[e],this.#s.delete(i),this.#n--,e}has(t,e={}){const{updateAgeOnHas:i=this.updateAgeOnHas,status:s}=e,n=this.#s.get(t);if(n!==void 0){const h=this.#t[n];if(this.#e(h)&&h.__staleWhileFetching===void 0)return!1;if(this.#g(n))s&&(s.has="stale",this.#E(s,n));else return i&&this.#T(n),s&&(s.has="hit",this.#E(s,n)),!0}else s&&(s.has="miss");return!1}peek(t,e={}){const{allowStale:i=this.allowStale}=e,s=this.#s.get(t);if(s===void 0||!i&&this.#g(s))return;const n=this.#t[s];return this.#e(n)?n.__staleWhileFetching:n}#x(t,e,i,s){const n=e===void 0?void 0:this.#t[e];if(this.#e(n))return n;const h=new R,{signal:o}=i;o?.addEventListener("abort",()=>h.abort(o.reason),{signal:h.signal});const r={signal:h.signal,options:i,context:s},g=(d,_=!1)=>{const{aborted:l}=h.signal,w=i.ignoreFetchAbort&&d!==void 0;if(i.status&&(l&&!_?(i.status.fetchAborted=!0,i.status.fetchError=h.signal.reason,w&&(i.status.fetchAbortIgnored=!0)):i.status.fetchResolved=!0),l&&!w&&!_)return f(h.signal.reason);const b=c;return this.#t[e]===c&&(d===void 0?b.__staleWhileFetching?this.#t[e]=b.__staleWhileFetching:this.#F(t,"fetch"):(i.status&&(i.status.fetchUpdated=!0),this.set(t,d,r.options))),d},S=d=>(i.status&&(i.status.fetchRejected=!0,i.status.fetchError=d),f(d)),f=d=>{const{aborted:_}=h.signal,l=_&&i.allowStaleOnFetchAbort,w=l||i.allowStaleOnFetchRejection,b=w||i.noDeleteOnFetchRejection,p=c;if(this.#t[e]===c&&(!b||p.__staleWhileFetching===void 0?this.#F(t,"fetch"):l||(this.#t[e]=p.__staleWhileFetching)),w)return i.status&&p.__staleWhileFetching!==void 0&&(i.status.returnedStale=!0),p.__staleWhileFetching;if(p.__returned===p)throw d},u=(d,_)=>{const l=this.#R?.(t,n,r);l&&l instanceof Promise&&l.then(w=>d(w===void 0?void 0:w),_),h.signal.addEventListener("abort",()=>{(!i.ignoreFetchAbort||i.allowStaleOnFetchAbort)&&(d(void 0),i.allowStaleOnFetchAbort&&(d=w=>g(w,!0)))})};i.status&&(i.status.fetchDispatched=!0);const c=new Promise(u).then(g,S),v=Object.assign(c,{__abortController:h,__staleWhileFetching:n,__returned:void 0});return e===void 0?(this.set(t,v,{...r.options,status:void 0}),e=this.#s.get(t)):this.#t[e]=v,v}#e(t){if(!this.#O)return!1;const e=t;return!!e&&e instanceof Promise&&e.hasOwnProperty("__staleWhileFetching")&&e.__abortController instanceof R}async fetch(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,ttl:h=this.ttl,noDisposeOnSet:o=this.noDisposeOnSet,size:r=0,sizeCalculation:g=this.sizeCalculation,noUpdateTTL:S=this.noUpdateTTL,noDeleteOnFetchRejection:f=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection:u=this.allowStaleOnFetchRejection,ignoreFetchAbort:c=this.ignoreFetchAbort,allowStaleOnFetchAbort:v=this.allowStaleOnFetchAbort,context:d,forceRefresh:_=!1,status:l,signal:w}=e;if(!this.#O)return l&&(l.fetch="get"),this.get(t,{allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,status:l});const b={allowStale:i,updateAgeOnGet:s,noDeleteOnStaleGet:n,ttl:h,noDisposeOnSet:o,size:r,sizeCalculation:g,noUpdateTTL:S,noDeleteOnFetchRejection:f,allowStaleOnFetchRejection:u,allowStaleOnFetchAbort:v,ignoreFetchAbort:c,status:l,signal:w};let p=this.#s.get(t);if(p===void 0){l&&(l.fetch="miss");const m=this.#x(t,p,b,d);return m.__returned=m}else{const m=this.#t[p];if(this.#e(m)){const M=i&&m.__staleWhileFetching!==void 0;return l&&(l.fetch="inflight",M&&(l.returnedStale=!0)),M?m.__staleWhileFetching:m.__returned=m}const O=this.#g(p);if(!_&&!O)return l&&(l.fetch="hit"),this.#C(p),s&&this.#T(p),l&&this.#E(l,p),m;const y=this.#x(t,p,b,d),W=y.__staleWhileFetching!==void 0&&i;return l&&(l.fetch=O?"stale":"refresh",W&&O&&(l.returnedStale=!0)),W?y.__staleWhileFetching:y.__returned=y}}async forceFetch(t,e={}){const i=await this.fetch(t,e);if(i===void 0)throw new Error("fetch() returned undefined");return i}memo(t,e={}){const i=this.#W;if(!i)throw new Error("no memoMethod provided to constructor");const{context:s,forceRefresh:n,...h}=e,o=this.get(t,h);if(!n&&o!==void 0)return o;const r=i(t,o,{options:h,context:s});return this.set(t,r,h),r}get(t,e={}){const{allowStale:i=this.allowStale,updateAgeOnGet:s=this.updateAgeOnGet,noDeleteOnStaleGet:n=this.noDeleteOnStaleGet,status:h}=e,o=this.#s.get(t);if(o!==void 0){const r=this.#t[o],g=this.#e(r);return h&&this.#E(h,o),this.#g(o)?(h&&(h.get="stale"),g?(h&&i&&r.__staleWhileFetching!==void 0&&(h.returnedStale=!0),i?r.__staleWhileFetching:void 0):(n||this.#F(t,"expire"),h&&i&&(h.returnedStale=!0),i?r:void 0)):(h&&(h.get="hit"),g?r.__staleWhileFetching:(this.#C(o),s&&this.#T(o),r))}else h&&(h.get="miss")}#N(t,e){this.#u[e]=t,this.#l[t]=e}#C(t){t!==this.#h&&(t===this.#o?this.#o=this.#l[t]:this.#N(this.#u[t],this.#l[t]),this.#N(this.#h,t),this.#h=t)}delete(t){return this.#F(t,"delete")}#F(t,e){let i=!1;if(this.#n!==0){const s=this.#s.get(t);if(s!==void 0)if(i=!0,this.#n===1)this.#P(e);else{this.#z(s);const n=this.#t[s];if(this.#e(n)?n.__abortController.abort(new Error("deleted")):(this.#y||this.#f)&&(this.#y&&this.#p?.(n,t,e),this.#f&&this.#r?.push([n,t,e])),this.#s.delete(t),this.#i[s]=void 0,this.#t[s]=void 0,s===this.#h)this.#h=this.#u[s];else if(s===this.#o)this.#o=this.#l[s];else{const h=this.#u[s];this.#l[h]=this.#l[s];const o=this.#l[s];this.#u[o]=this.#u[s]}this.#n--,this.#m.push(s)}}if(this.#f&&this.#r?.length){const s=this.#r;let n;for(;n=s?.shift();)this.#w?.(...n)}return i}clear(){return this.#P("delete")}#P(t){for(const e of this.#v({allowStale:!0})){const i=this.#t[e];if(this.#e(i))i.__abortController.abort(new Error("deleted"));else{const s=this.#i[e];this.#y&&this.#p?.(i,s,t),this.#f&&this.#r?.push([i,s,t])}}if(this.#s.clear(),this.#t.fill(void 0),this.#i.fill(void 0),this.#d&&this.#b&&(this.#d.fill(0),this.#b.fill(0)),this.#S&&this.#S.fill(0),this.#o=0,this.#h=0,this.#m.length=0,this.#_=0,this.#n=0,this.#f&&this.#r){const e=this.#r;let i;for(;i=e?.shift();)this.#w?.(...i)}}}var k=Object.defineProperty,X=(a,t,e)=>t in a?k(a,t,{enumerable:!0,configurable:!0,writable:!0,value:e}):a[t]=e,$=(a,t,e)=>(X(a,t+"",e),e),C=class{constructor(){}static getInstance(a=1e4,t=1e3*60*10){if(!C.instance){const e={max:a,length:()=>1,maxAge:t};C.instance=new x(e)}return C.instance}},j=C;$(j,"instance");var q=j,I=q.getInstance(),H,L,Y=async(a="Xenova/gte-small")=>{if(a!==L){const e=(await V(()=>import("./transformers-CZ2y5aXR.js"),__vite__mapDeps([0,1]))).pipeline;H=await e("feature-extraction",a),L=a}},it=async(a,t=7,e={pooling:"mean",normalize:!1},i="Xenova/gte-small")=>{const s=I.get(a);if(s)return Promise.resolve(s);i!==L&&await Y(i);const n=await H(a,e),h=Array.from(n.data).map(o=>parseFloat(o.toFixed(t)));return I.set(a,h),Array.from(h)};export{it as getEmbedding,Y as initializeModel};
