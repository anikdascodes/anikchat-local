{
  "version": 3,
  "sources": ["../../lru-cache/src/index.ts", "../../@msgpack/msgpack/src/utils/utf8.ts", "../../@msgpack/msgpack/src/ExtData.ts", "../../@msgpack/msgpack/src/DecodeError.ts", "../../@msgpack/msgpack/src/utils/int.ts", "../../@msgpack/msgpack/src/timestamp.ts", "../../@msgpack/msgpack/src/ExtensionCodec.ts", "../../@msgpack/msgpack/src/utils/typedArrays.ts", "../../@msgpack/msgpack/src/Encoder.ts", "../../@msgpack/msgpack/src/encode.ts", "../../@msgpack/msgpack/src/utils/prettyByte.ts", "../../@msgpack/msgpack/src/CachedKeyDecoder.ts", "../../@msgpack/msgpack/src/Decoder.ts", "../../@msgpack/msgpack/src/decode.ts", "../../client-vector-search/dist/index.mjs"],
  "sourcesContent": ["/**\n * @module LRUCache\n */\n\n// module-private names and types\ntype Perf = { now: () => number }\nconst perf: Perf =\n  typeof performance === 'object' &&\n  performance &&\n  typeof performance.now === 'function'\n    ? performance\n    : Date\n\nconst warned = new Set<string>()\n\n// either a function or a class\ntype ForC = ((...a: any[]) => any) | { new (...a: any[]): any }\n\n/* c8 ignore start */\nconst PROCESS = (\n  typeof process === 'object' && !!process ? process : {}\n) as { [k: string]: any }\n/* c8 ignore start */\n\nconst emitWarning = (\n  msg: string,\n  type: string,\n  code: string,\n  fn: ForC\n) => {\n  typeof PROCESS.emitWarning === 'function'\n    ? PROCESS.emitWarning(msg, type, code, fn)\n    : console.error(`[${code}] ${type}: ${msg}`)\n}\n\nlet AC = globalThis.AbortController\nlet AS = globalThis.AbortSignal\n\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n  //@ts-ignore\n  AS = class AbortSignal {\n    onabort?: (...a: any[]) => any\n    _onabort: ((...a: any[]) => any)[] = []\n    reason?: any\n    aborted: boolean = false\n    addEventListener(_: string, fn: (...a: any[]) => any) {\n      this._onabort.push(fn)\n    }\n  }\n  //@ts-ignore\n  AC = class AbortController {\n    constructor() {\n      warnACPolyfill()\n    }\n    signal = new AS()\n    abort(reason: any) {\n      if (this.signal.aborted) return\n      //@ts-ignore\n      this.signal.reason = reason\n      //@ts-ignore\n      this.signal.aborted = true\n      //@ts-ignore\n      for (const fn of this.signal._onabort) {\n        fn(reason)\n      }\n      this.signal.onabort?.(reason)\n    }\n  }\n  let printACPolyfillWarning =\n    PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1'\n  const warnACPolyfill = () => {\n    if (!printACPolyfillWarning) return\n    printACPolyfillWarning = false\n    emitWarning(\n      'AbortController is not defined. If using lru-cache in ' +\n        'node 14, load an AbortController polyfill from the ' +\n        '`node-abort-controller` package. A minimal polyfill is ' +\n        'provided for use by LRUCache.fetch(), but it should not be ' +\n        'relied upon in other contexts (eg, passing it to other APIs that ' +\n        'use AbortController/AbortSignal might have undesirable effects). ' +\n        'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.',\n      'NO_ABORT_CONTROLLER',\n      'ENOTSUP',\n      warnACPolyfill\n    )\n  }\n}\n/* c8 ignore stop */\n\nconst shouldWarn = (code: string) => !warned.has(code)\n\nconst TYPE = Symbol('type')\nexport type PosInt = number & { [TYPE]: 'Positive Integer' }\nexport type Index = number & { [TYPE]: 'LRUCache Index' }\n\nconst isPosInt = (n: any): n is PosInt =>\n  n && n === Math.floor(n) && n > 0 && isFinite(n)\n\nexport type UintArray = Uint8Array | Uint16Array | Uint32Array\nexport type NumberArray = UintArray | number[]\n\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max: number) =>\n  !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n    ? Uint8Array\n    : max <= Math.pow(2, 16)\n    ? Uint16Array\n    : max <= Math.pow(2, 32)\n    ? Uint32Array\n    : max <= Number.MAX_SAFE_INTEGER\n    ? ZeroArray\n    : null\n/* c8 ignore stop */\n\nclass ZeroArray extends Array<number> {\n  constructor(size: number) {\n    super(size)\n    this.fill(0)\n  }\n}\nexport type { ZeroArray }\nexport type { Stack }\n\nexport type StackLike = Stack | Index[]\nclass Stack {\n  heap: NumberArray\n  length: number\n  // private constructor\n  static #constructing: boolean = false\n  static create(max: number): StackLike {\n    const HeapCls = getUintArray(max)\n    if (!HeapCls) return []\n    Stack.#constructing = true\n    const s = new Stack(max, HeapCls)\n    Stack.#constructing = false\n    return s\n  }\n  constructor(\n    max: number,\n    HeapCls: { new (n: number): NumberArray }\n  ) {\n    /* c8 ignore start */\n    if (!Stack.#constructing) {\n      throw new TypeError('instantiate Stack using Stack.create(n)')\n    }\n    /* c8 ignore stop */\n    this.heap = new HeapCls(max)\n    this.length = 0\n  }\n  push(n: Index) {\n    this.heap[this.length++] = n\n  }\n  pop(): Index {\n    return this.heap[--this.length] as Index\n  }\n}\n\n/**\n * Promise representing an in-progress {@link LRUCache#fetch} call\n */\nexport type BackgroundFetch<V> = Promise<V | undefined> & {\n  __returned: BackgroundFetch<V> | undefined\n  __abortController: AbortController\n  __staleWhileFetching: V | undefined\n}\n\nexport type DisposeTask<K, V> = [\n  value: V,\n  key: K,\n  reason: LRUCache.DisposeReason\n]\n\nexport namespace LRUCache {\n  /**\n   * An integer greater than 0, reflecting the calculated size of items\n   */\n  export type Size = number\n\n  /**\n   * Integer greater than 0, representing some number of milliseconds, or the\n   * time at which a TTL started counting from.\n   */\n  export type Milliseconds = number\n\n  /**\n   * An integer greater than 0, reflecting a number of items\n   */\n  export type Count = number\n\n  /**\n   * The reason why an item was removed from the cache, passed\n   * to the {@link Disposer} methods.\n   *\n   * - `evict`: The item was evicted because it is the least recently used,\n   *   and the cache is full.\n   * - `set`: A new value was set, overwriting the old value being disposed.\n   * - `delete`: The item was explicitly deleted, either by calling\n   *   {@link LRUCache#delete}, {@link LRUCache#clear}, or\n   *   {@link LRUCache#set} with an undefined value.\n   * - `expire`: The item was removed due to exceeding its TTL.\n   * - `fetch`: A {@link OptionsBase#fetchMethod} operation returned\n   *   `undefined` or was aborted, causing the item to be deleted.\n   */\n  export type DisposeReason =\n    | 'evict'\n    | 'set'\n    | 'delete'\n    | 'expire'\n    | 'fetch'\n  /**\n   * A method called upon item removal, passed as the\n   * {@link OptionsBase.dispose} and/or\n   * {@link OptionsBase.disposeAfter} options.\n   */\n  export type Disposer<K, V> = (\n    value: V,\n    key: K,\n    reason: DisposeReason\n  ) => void\n\n  /**\n   * A function that returns the effective calculated size\n   * of an entry in the cache.\n   */\n  export type SizeCalculator<K, V> = (value: V, key: K) => Size\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.fetchMethod} function.\n   */\n  export interface FetcherOptions<K, V, FC = unknown> {\n    signal: AbortSignal\n    options: FetcherFetchOptions<K, V, FC>\n    /**\n     * Object provided in the {@link FetchOptions.context} option to\n     * {@link LRUCache#fetch}\n     */\n    context: FC\n  }\n\n  /**\n   * Occasionally, it may be useful to track the internal behavior of the\n   * cache, particularly for logging, debugging, or for behavior within the\n   * `fetchMethod`. To do this, you can pass a `status` object to the\n   * {@link LRUCache#fetch}, {@link LRUCache#get}, {@link LRUCache#set},\n   * {@link LRUCache#memo}, and {@link LRUCache#has} methods.\n   *\n   * The `status` option should be a plain JavaScript object. The following\n   * fields will be set on it appropriately, depending on the situation.\n   */\n  export interface Status<V> {\n    /**\n     * The status of a set() operation.\n     *\n     * - add: the item was not found in the cache, and was added\n     * - update: the item was in the cache, with the same value provided\n     * - replace: the item was in the cache, and replaced\n     * - miss: the item was not added to the cache for some reason\n     */\n    set?: 'add' | 'update' | 'replace' | 'miss'\n\n    /**\n     * the ttl stored for the item, or undefined if ttls are not used.\n     */\n    ttl?: Milliseconds\n\n    /**\n     * the start time for the item, or undefined if ttls are not used.\n     */\n    start?: Milliseconds\n\n    /**\n     * The timestamp used for TTL calculation\n     */\n    now?: Milliseconds\n\n    /**\n     * the remaining ttl for the item, or undefined if ttls are not used.\n     */\n    remainingTTL?: Milliseconds\n\n    /**\n     * The calculated size for the item, if sizes are used.\n     */\n    entrySize?: Size\n\n    /**\n     * The total calculated size of the cache, if sizes are used.\n     */\n    totalCalculatedSize?: Size\n\n    /**\n     * A flag indicating that the item was not stored, due to exceeding the\n     * {@link OptionsBase.maxEntrySize}\n     */\n    maxEntrySizeExceeded?: true\n\n    /**\n     * The old value, specified in the case of `set:'update'` or\n     * `set:'replace'`\n     */\n    oldValue?: V\n\n    /**\n     * The results of a {@link LRUCache#has} operation\n     *\n     * - hit: the item was found in the cache\n     * - stale: the item was found in the cache, but is stale\n     * - miss: the item was not found in the cache\n     */\n    has?: 'hit' | 'stale' | 'miss'\n\n    /**\n     * The status of a {@link LRUCache#fetch} operation.\n     * Note that this can change as the underlying fetch() moves through\n     * various states.\n     *\n     * - inflight: there is another fetch() for this key which is in process\n     * - get: there is no {@link OptionsBase.fetchMethod}, so\n     *   {@link LRUCache#get} was called.\n     * - miss: the item is not in cache, and will be fetched.\n     * - hit: the item is in the cache, and was resolved immediately.\n     * - stale: the item is in the cache, but stale.\n     * - refresh: the item is in the cache, and not stale, but\n     *   {@link FetchOptions.forceRefresh} was specified.\n     */\n    fetch?: 'get' | 'inflight' | 'miss' | 'hit' | 'stale' | 'refresh'\n\n    /**\n     * The {@link OptionsBase.fetchMethod} was called\n     */\n    fetchDispatched?: true\n\n    /**\n     * The cached value was updated after a successful call to\n     * {@link OptionsBase.fetchMethod}\n     */\n    fetchUpdated?: true\n\n    /**\n     * The reason for a fetch() rejection.  Either the error raised by the\n     * {@link OptionsBase.fetchMethod}, or the reason for an\n     * AbortSignal.\n     */\n    fetchError?: Error\n\n    /**\n     * The fetch received an abort signal\n     */\n    fetchAborted?: true\n\n    /**\n     * The abort signal received was ignored, and the fetch was allowed to\n     * continue.\n     */\n    fetchAbortIgnored?: true\n\n    /**\n     * The fetchMethod promise resolved successfully\n     */\n    fetchResolved?: true\n\n    /**\n     * The fetchMethod promise was rejected\n     */\n    fetchRejected?: true\n\n    /**\n     * The status of a {@link LRUCache#get} operation.\n     *\n     * - fetching: The item is currently being fetched.  If a previous value\n     *   is present and allowed, that will be returned.\n     * - stale: The item is in the cache, and is stale.\n     * - hit: the item is in the cache\n     * - miss: the item is not in the cache\n     */\n    get?: 'stale' | 'hit' | 'miss'\n\n    /**\n     * A fetch or get operation returned a stale value.\n     */\n    returnedStale?: true\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#fetch}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link OptionsBase.noDeleteOnFetchRejection},\n   * {@link OptionsBase.allowStaleOnFetchRejection},\n   * {@link FetchOptions.forceRefresh}, and\n   * {@link FetcherOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.fetchMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the fetchMethod is called.\n   */\n  export interface FetcherFetchOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    status?: Status<V>\n    size?: Size\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#fetch} method.\n   */\n  export interface FetchOptions<K, V, FC>\n    extends FetcherFetchOptions<K, V, FC> {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.fetchMethod} as\n     * the {@link FetcherOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    signal?: AbortSignal\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface FetchOptionsWithContext<K, V, FC>\n    extends FetchOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#fetch} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface FetchOptionsNoContext<K, V>\n    extends FetchOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  export interface MemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n      | 'noDeleteOnFetchRejection'\n      | 'allowStaleOnFetchRejection'\n      | 'ignoreFetchAbort'\n      | 'allowStaleOnFetchAbort'\n    > {\n    /**\n     * Set to true to force a re-load of the existing data, even if it\n     * is not yet stale.\n     */\n    forceRefresh?: boolean\n    /**\n     * Context provided to the {@link OptionsBase.memoMethod} as\n     * the {@link MemoizerOptions.context} param.\n     *\n     * If the FC type is specified as unknown (the default),\n     * undefined or void, then this is optional.  Otherwise, it will\n     * be required.\n     */\n    context?: FC\n    status?: Status<V>\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is something\n   * other than `unknown`, `undefined`, or `void`\n   */\n  export interface MemoOptionsWithContext<K, V, FC>\n    extends MemoOptions<K, V, FC> {\n    context: FC\n  }\n  /**\n   * Options provided to {@link LRUCache#memo} when the FC type is\n   * `undefined` or `void`\n   */\n  export interface MemoOptionsNoContext<K, V>\n    extends MemoOptions<K, V, undefined> {\n    context?: undefined\n  }\n\n  /**\n   * Options provided to the\n   * {@link OptionsBase.memoMethod} function.\n   */\n  export interface MemoizerOptions<K, V, FC = unknown> {\n    options: MemoizerMemoOptions<K, V, FC>\n    /**\n     * Object provided in the {@link MemoOptions.context} option to\n     * {@link LRUCache#memo}\n     */\n    context: FC\n  }\n\n  /**\n   * options which override the options set in the LRUCache constructor\n   * when calling {@link LRUCache#memo}.\n   *\n   * This is the union of {@link GetOptions} and {@link SetOptions}, plus\n   * {@link MemoOptions.forceRefresh}, and\n   * {@link MemoerOptions.context}\n   *\n   * Any of these may be modified in the {@link OptionsBase.memoMethod}\n   * function, but the {@link GetOptions} fields will of course have no\n   * effect, as the {@link LRUCache#get} call already happened by the time\n   * the memoMethod is called.\n   */\n  export interface MemoizerMemoOptions<K, V, FC = unknown>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      | 'allowStale'\n      | 'updateAgeOnGet'\n      | 'noDeleteOnStaleGet'\n      | 'sizeCalculation'\n      | 'ttl'\n      | 'noDisposeOnSet'\n      | 'noUpdateTTL'\n    > {\n    status?: Status<V>\n    size?: Size\n    start?: Milliseconds\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#has} method.\n   */\n  export interface HasOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'updateAgeOnHas'> {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#get} method.\n   */\n  export interface GetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'allowStale' | 'updateAgeOnGet' | 'noDeleteOnStaleGet'\n    > {\n    status?: Status<V>\n  }\n\n  /**\n   * Options that may be passed to the {@link LRUCache#peek} method.\n   */\n  export interface PeekOptions<K, V, FC>\n    extends Pick<OptionsBase<K, V, FC>, 'allowStale'> {}\n\n  /**\n   * Options that may be passed to the {@link LRUCache#set} method.\n   */\n  export interface SetOptions<K, V, FC>\n    extends Pick<\n      OptionsBase<K, V, FC>,\n      'sizeCalculation' | 'ttl' | 'noDisposeOnSet' | 'noUpdateTTL'\n    > {\n    /**\n     * If size tracking is enabled, then setting an explicit size\n     * in the {@link LRUCache#set} call will prevent calling the\n     * {@link OptionsBase.sizeCalculation} function.\n     */\n    size?: Size\n    /**\n     * If TTL tracking is enabled, then setting an explicit start\n     * time in the {@link LRUCache#set} call will override the\n     * default time from `performance.now()` or `Date.now()`.\n     *\n     * Note that it must be a valid value for whichever time-tracking\n     * method is in use.\n     */\n    start?: Milliseconds\n    status?: Status<V>\n  }\n\n  /**\n   * The type signature for the {@link OptionsBase.fetchMethod} option.\n   */\n  export type Fetcher<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: FetcherOptions<K, V, FC>\n  ) => Promise<V | undefined | void> | V | undefined | void\n\n  /**\n   * the type signature for the {@link OptionsBase.memoMethod} option.\n   */\n  export type Memoizer<K, V, FC = unknown> = (\n    key: K,\n    staleValue: V | undefined,\n    options: MemoizerOptions<K, V, FC>\n  ) => V\n\n  /**\n   * Options which may be passed to the {@link LRUCache} constructor.\n   *\n   * Most of these may be overridden in the various options that use\n   * them.\n   *\n   * Despite all being technically optional, the constructor requires that\n   * a cache is at minimum limited by one or more of {@link OptionsBase.max},\n   * {@link OptionsBase.ttl}, or {@link OptionsBase.maxSize}.\n   *\n   * If {@link OptionsBase.ttl} is used alone, then it is strongly advised\n   * (and in fact required by the type definitions here) that the cache\n   * also set {@link OptionsBase.ttlAutopurge}, to prevent potentially\n   * unbounded storage.\n   *\n   * All options are also available on the {@link LRUCache} instance, making\n   * it safe to pass an LRUCache instance as the options argumemnt to\n   * make another empty cache of the same type.\n   *\n   * Some options are marked as read-only, because changing them after\n   * instantiation is not safe. Changing any of the other options will of\n   * course only have an effect on subsequent method calls.\n   */\n  export interface OptionsBase<K, V, FC> {\n    /**\n     * The maximum number of items to store in the cache before evicting\n     * old entries. This is read-only on the {@link LRUCache} instance,\n     * and may not be overridden.\n     *\n     * If set, then storage space will be pre-allocated at construction\n     * time, and the cache will perform significantly faster.\n     *\n     * Note that significantly fewer items may be stored, if\n     * {@link OptionsBase.maxSize} and/or {@link OptionsBase.ttl} are also\n     * set.\n     *\n     * **It is strongly recommended to set a `max` to prevent unbounded growth\n     * of the cache.**\n     */\n    max?: Count\n\n    /**\n     * Max time in milliseconds for items to live in cache before they are\n     * considered stale.  Note that stale items are NOT preemptively removed by\n     * default, and MAY live in the cache, contributing to its LRU max, long\n     * after they have expired, unless {@link OptionsBase.ttlAutopurge} is\n     * set.\n     *\n     * If set to `0` (the default value), then that means \"do not track\n     * TTL\", not \"expire immediately\".\n     *\n     * Also, as this cache is optimized for LRU/MRU operations, some of\n     * the staleness/TTL checks will reduce performance, as they will incur\n     * overhead by deleting items.\n     *\n     * This is not primarily a TTL cache, and does not make strong TTL\n     * guarantees. There is no pre-emptive pruning of expired items, but you\n     * _may_ set a TTL on the cache, and it will treat expired items as missing\n     * when they are fetched, and delete them.\n     *\n     * Optional, but must be a non-negative integer in ms if specified.\n     *\n     * This may be overridden by passing an options object to `cache.set()`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if ttl tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * If ttl tracking is enabled, and `max` and `maxSize` are not set,\n     * and `ttlAutopurge` is not set, then a warning will be emitted\n     * cautioning about the potential for unbounded memory consumption.\n     * (The TypeScript definitions will also discourage this.)\n     */\n    ttl?: Milliseconds\n\n    /**\n     * Minimum amount of time in ms in which to check for staleness.\n     * Defaults to 1, which means that the current time is checked\n     * at most once per millisecond.\n     *\n     * Set to 0 to check the current time every time staleness is tested.\n     * (This reduces performance, and is theoretically unnecessary.)\n     *\n     * Setting this to a higher value will improve performance somewhat\n     * while using ttl tracking, albeit at the expense of keeping stale\n     * items around a bit longer than their TTLs would indicate.\n     *\n     * @default 1\n     */\n    ttlResolution?: Milliseconds\n\n    /**\n     * Preemptively remove stale items from the cache.\n     *\n     * Note that this may *significantly* degrade performance, especially if\n     * the cache is storing a large number of items. It is almost always best\n     * to just leave the stale items in the cache, and let them fall out as new\n     * items are added.\n     *\n     * Note that this means that {@link OptionsBase.allowStale} is a bit\n     * pointless, as stale items will be deleted almost as soon as they\n     * expire.\n     *\n     * Use with caution!\n     */\n    ttlAutopurge?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever it is retrieved from cache with\n     * {@link LRUCache#get}, causing it to not expire. (It can still fall out\n     * of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     */\n    updateAgeOnGet?: boolean\n\n    /**\n     * When using time-expiring entries with `ttl`, setting this to `true` will\n     * make each item's age reset to 0 whenever its presence in the cache is\n     * checked with {@link LRUCache#has}, causing it to not expire. (It can\n     * still fall out of cache based on recency of use, of course.)\n     *\n     * Has no effect if {@link OptionsBase.ttl} is not set.\n     */\n    updateAgeOnHas?: boolean\n\n    /**\n     * Allow {@link LRUCache#get} and {@link LRUCache#fetch} calls to return\n     * stale data, if available.\n     *\n     * By default, if you set `ttl`, stale items will only be deleted from the\n     * cache when you `get(key)`. That is, it's not preemptively pruning items,\n     * unless {@link OptionsBase.ttlAutopurge} is set.\n     *\n     * If you set `allowStale:true`, it'll return the stale value *as well as*\n     * deleting it. If you don't set this, then it'll return `undefined` when\n     * you try to get a stale entry.\n     *\n     * Note that when a stale entry is fetched, _even if it is returned due to\n     * `allowStale` being set_, it is removed from the cache immediately. You\n     * can suppress this behavior by setting\n     * {@link OptionsBase.noDeleteOnStaleGet}, either in the constructor, or in\n     * the options provided to {@link LRUCache#get}.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     * The `cache.has()` method will always return `false` for stale items.\n     *\n     * Only relevant if a ttl is set.\n     */\n    allowStale?: boolean\n\n    /**\n     * Function that is called on items when they are dropped from the\n     * cache, as `dispose(value, key, reason)`.\n     *\n     * This can be handy if you want to close file descriptors or do\n     * other cleanup tasks when items are no longer stored in the cache.\n     *\n     * **NOTE**: It is called _before_ the item has been fully removed\n     * from the cache, so if you want to put it right back in, you need\n     * to wait until the next tick. If you try to add it back in during\n     * the `dispose()` function call, it will break things in subtle and\n     * weird ways.\n     *\n     * Unlike several other options, this may _not_ be overridden by\n     * passing an option to `set()`, for performance reasons.\n     *\n     * The `reason` will be one of the following strings, corresponding\n     * to the reason for the item's deletion:\n     *\n     * - `evict` Item was evicted to make space for a new addition\n     * - `set` Item was overwritten by a new value\n     * - `expire` Item expired its TTL\n     * - `fetch` Item was deleted due to a failed or aborted fetch, or a\n     *   fetchMethod returning `undefined.\n     * - `delete` Item was removed by explicit `cache.delete(key)`,\n     *   `cache.clear()`, or `cache.set(key, undefined)`.\n     */\n    dispose?: Disposer<K, V>\n\n    /**\n     * The same as {@link OptionsBase.dispose}, but called *after* the entry\n     * is completely removed and the cache is once again in a clean state.\n     *\n     * It is safe to add an item right back into the cache at this point.\n     * However, note that it is *very* easy to inadvertently create infinite\n     * recursion this way.\n     */\n    disposeAfter?: Disposer<K, V>\n\n    /**\n     * Set to true to suppress calling the\n     * {@link OptionsBase.dispose} function if the entry key is\n     * still accessible within the cache.\n     *\n     * This may be overridden by passing an options object to\n     * {@link LRUCache#set}.\n     *\n     * Only relevant if `dispose` or `disposeAfter` are set.\n     */\n    noDisposeOnSet?: boolean\n\n    /**\n     * Boolean flag to tell the cache to not update the TTL when setting a new\n     * value for an existing key (ie, when updating a value rather than\n     * inserting a new value).  Note that the TTL value is _always_ set (if\n     * provided) when adding a new entry into the cache.\n     *\n     * Has no effect if a {@link OptionsBase.ttl} is not set.\n     *\n     * May be passed as an option to {@link LRUCache#set}.\n     */\n    noUpdateTTL?: boolean\n\n    /**\n     * Set to a positive integer to track the sizes of items added to the\n     * cache, and automatically evict items in order to stay below this size.\n     * Note that this may result in fewer than `max` items being stored.\n     *\n     * Attempting to add an item to the cache whose calculated size is greater\n     * that this amount will be a no-op. The item will not be cached, and no\n     * other items will be evicted.\n     *\n     * Optional, must be a positive integer if provided.\n     *\n     * Sets `maxEntrySize` to the same value, unless a different value is\n     * provided for `maxEntrySize`.\n     *\n     * At least one of `max`, `maxSize`, or `TTL` is required. This must be a\n     * positive integer if set.\n     *\n     * Even if size tracking is enabled, **it is strongly recommended to set a\n     * `max` to prevent unbounded growth of the cache.**\n     *\n     * Note also that size tracking can negatively impact performance,\n     * though for most cases, only minimally.\n     */\n    maxSize?: Size\n\n    /**\n     * The maximum allowed size for any single item in the cache.\n     *\n     * If a larger item is passed to {@link LRUCache#set} or returned by a\n     * {@link OptionsBase.fetchMethod} or {@link OptionsBase.memoMethod}, then\n     * it will not be stored in the cache.\n     *\n     * Attempting to add an item whose calculated size is greater than\n     * this amount will not cache the item or evict any old items, but\n     * WILL delete an existing value if one is already present.\n     *\n     * Optional, must be a positive integer if provided. Defaults to\n     * the value of `maxSize` if provided.\n     */\n    maxEntrySize?: Size\n\n    /**\n     * A function that returns a number indicating the item's size.\n     *\n     * Requires {@link OptionsBase.maxSize} to be set.\n     *\n     * If not provided, and {@link OptionsBase.maxSize} or\n     * {@link OptionsBase.maxEntrySize} are set, then all\n     * {@link LRUCache#set} calls **must** provide an explicit\n     * {@link SetOptions.size} or sizeCalculation param.\n     */\n    sizeCalculation?: SizeCalculator<K, V>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#fetch}\n     *\n     * ```ts\n     * fetchMethod(key, staleValue, { signal, options, context })\n     * ```\n     *\n     * If `fetchMethod` is not provided, then `cache.fetch(key)` is equivalent\n     * to `Promise.resolve(cache.get(key))`.\n     *\n     * If at any time, `signal.aborted` is set to `true`, or if the\n     * `signal.onabort` method is called, or if it emits an `'abort'` event\n     * which you can listen to with `addEventListener`, then that means that\n     * the fetch should be abandoned. This may be passed along to async\n     * functions aware of AbortController/AbortSignal behavior.\n     *\n     * The `fetchMethod` should **only** return `undefined` or a Promise\n     * resolving to `undefined` if the AbortController signaled an `abort`\n     * event. In all other cases, it should return or resolve to a value\n     * suitable for adding to the cache.\n     *\n     * The `options` object is a union of the options that may be provided to\n     * `set()` and `get()`. If they are modified, then that will result in\n     * modifying the settings to `cache.set()` when the value is resolved, and\n     * in the case of\n     * {@link OptionsBase.noDeleteOnFetchRejection} and\n     * {@link OptionsBase.allowStaleOnFetchRejection}, the handling of\n     * `fetchMethod` failures.\n     *\n     * For example, a DNS cache may update the TTL based on the value returned\n     * from a remote DNS server by changing `options.ttl` in the `fetchMethod`.\n     */\n    fetchMethod?: Fetcher<K, V, FC>\n\n    /**\n     * Method that provides the implementation for {@link LRUCache#memo}\n     */\n    memoMethod?: Memoizer<K, V, FC>\n\n    /**\n     * Set to true to suppress the deletion of stale data when a\n     * {@link OptionsBase.fetchMethod} returns a rejected promise.\n     */\n    noDeleteOnFetchRejection?: boolean\n\n    /**\n     * Do not delete stale items when they are retrieved with\n     * {@link LRUCache#get}.\n     *\n     * Note that the `get` return value will still be `undefined`\n     * unless {@link OptionsBase.allowStale} is true.\n     *\n     * When using time-expiring entries with `ttl`, by default stale\n     * items will be removed from the cache when the key is accessed\n     * with `cache.get()`.\n     *\n     * Setting this option will cause stale items to remain in the cache, until\n     * they are explicitly deleted with `cache.delete(key)`, or retrieved with\n     * `noDeleteOnStaleGet` set to `false`.\n     *\n     * This may be overridden by passing an options object to `cache.get()`.\n     *\n     * Only relevant if a ttl is used.\n     */\n    noDeleteOnStaleGet?: boolean\n\n    /**\n     * Set to true to allow returning stale data when a\n     * {@link OptionsBase.fetchMethod} throws an error or returns a rejected\n     * promise.\n     *\n     * This differs from using {@link OptionsBase.allowStale} in that stale\n     * data will ONLY be returned in the case that the {@link LRUCache#fetch}\n     * fails, not any other times.\n     *\n     * If a `fetchMethod` fails, and there is no stale value available, the\n     * `fetch()` will resolve to `undefined`. Ie, all `fetchMethod` errors are\n     * suppressed.\n     *\n     * Implies `noDeleteOnFetchRejection`.\n     *\n     * This may be set in calls to `fetch()`, or defaulted on the constructor,\n     * or overridden by modifying the options object in the `fetchMethod`.\n     */\n    allowStaleOnFetchRejection?: boolean\n\n    /**\n     * Set to true to return a stale value from the cache when the\n     * `AbortSignal` passed to the {@link OptionsBase.fetchMethod} dispatches\n     * an `'abort'` event, whether user-triggered, or due to internal cache\n     * behavior.\n     *\n     * Unless {@link OptionsBase.ignoreFetchAbort} is also set, the underlying\n     * {@link OptionsBase.fetchMethod} will still be considered canceled, and\n     * any value it returns will be ignored and not cached.\n     *\n     * Caveat: since fetches are aborted when a new value is explicitly\n     * set in the cache, this can lead to fetch returning a stale value,\n     * since that was the fallback value _at the moment the `fetch()` was\n     * initiated_, even though the new updated value is now present in\n     * the cache.\n     *\n     * For example:\n     *\n     * ```ts\n     * const cache = new LRUCache<string, any>({\n     *   ttl: 100,\n     *   fetchMethod: async (url, oldValue, { signal }) =>  {\n     *     const res = await fetch(url, { signal })\n     *     return await res.json()\n     *   }\n     * })\n     * cache.set('https://example.com/', { some: 'data' })\n     * // 100ms go by...\n     * const result = cache.fetch('https://example.com/')\n     * cache.set('https://example.com/', { other: 'thing' })\n     * console.log(await result) // { some: 'data' }\n     * console.log(cache.get('https://example.com/')) // { other: 'thing' }\n     * ```\n     */\n    allowStaleOnFetchAbort?: boolean\n\n    /**\n     * Set to true to ignore the `abort` event emitted by the `AbortSignal`\n     * object passed to {@link OptionsBase.fetchMethod}, and still cache the\n     * resulting resolution value, as long as it is not `undefined`.\n     *\n     * When used on its own, this means aborted {@link LRUCache#fetch} calls\n     * are not immediately resolved or rejected when they are aborted, and\n     * instead take the full time to await.\n     *\n     * When used with {@link OptionsBase.allowStaleOnFetchAbort}, aborted\n     * {@link LRUCache#fetch} calls will resolve immediately to their stale\n     * cached value or `undefined`, and will continue to process and eventually\n     * update the cache when they resolve, as long as the resulting value is\n     * not `undefined`, thus supporting a \"return stale on timeout while\n     * refreshing\" mechanism by passing `AbortSignal.timeout(n)` as the signal.\n     *\n     * For example:\n     *\n     * ```ts\n     * const c = new LRUCache({\n     *   ttl: 100,\n     *   ignoreFetchAbort: true,\n     *   allowStaleOnFetchAbort: true,\n     *   fetchMethod: async (key, oldValue, { signal }) => {\n     *     // note: do NOT pass the signal to fetch()!\n     *     // let's say this fetch can take a long time.\n     *     const res = await fetch(`https://slow-backend-server/${key}`)\n     *     return await res.json()\n     *   },\n     * })\n     *\n     * // this will return the stale value after 100ms, while still\n     * // updating in the background for next time.\n     * const val = await c.fetch('key', { signal: AbortSignal.timeout(100) })\n     * ```\n     *\n     * **Note**: regardless of this setting, an `abort` event _is still\n     * emitted on the `AbortSignal` object_, so may result in invalid results\n     * when passed to other underlying APIs that use AbortSignals.\n     *\n     * This may be overridden in the {@link OptionsBase.fetchMethod} or the\n     * call to {@link LRUCache#fetch}.\n     */\n    ignoreFetchAbort?: boolean\n  }\n\n  export interface OptionsMaxLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    max: Count\n  }\n  export interface OptionsTTLLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    ttl: Milliseconds\n    ttlAutopurge: boolean\n  }\n  export interface OptionsSizeLimit<K, V, FC>\n    extends OptionsBase<K, V, FC> {\n    maxSize: Size\n  }\n\n  /**\n   * The valid safe options for the {@link LRUCache} constructor\n   */\n  export type Options<K, V, FC> =\n    | OptionsMaxLimit<K, V, FC>\n    | OptionsSizeLimit<K, V, FC>\n    | OptionsTTLLimit<K, V, FC>\n\n  /**\n   * Entry objects used by {@link LRUCache#load} and {@link LRUCache#dump},\n   * and returned by {@link LRUCache#info}.\n   */\n  export interface Entry<V> {\n    value: V\n    ttl?: Milliseconds\n    size?: Size\n    start?: Milliseconds\n  }\n}\n\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nexport class LRUCache<K extends {}, V extends {}, FC = unknown>\n  implements Map<K, V>\n{\n  // options that cannot be changed without disaster\n  readonly #max: LRUCache.Count\n  readonly #maxSize: LRUCache.Size\n  readonly #dispose?: LRUCache.Disposer<K, V>\n  readonly #disposeAfter?: LRUCache.Disposer<K, V>\n  readonly #fetchMethod?: LRUCache.Fetcher<K, V, FC>\n  readonly #memoMethod?: LRUCache.Memoizer<K, V, FC>\n\n  /**\n   * {@link LRUCache.OptionsBase.ttl}\n   */\n  ttl: LRUCache.Milliseconds\n\n  /**\n   * {@link LRUCache.OptionsBase.ttlResolution}\n   */\n  ttlResolution: LRUCache.Milliseconds\n  /**\n   * {@link LRUCache.OptionsBase.ttlAutopurge}\n   */\n  ttlAutopurge: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnGet}\n   */\n  updateAgeOnGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.updateAgeOnHas}\n   */\n  updateAgeOnHas: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStale}\n   */\n  allowStale: boolean\n\n  /**\n   * {@link LRUCache.OptionsBase.noDisposeOnSet}\n   */\n  noDisposeOnSet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noUpdateTTL}\n   */\n  noUpdateTTL: boolean\n  /**\n   * {@link LRUCache.OptionsBase.maxEntrySize}\n   */\n  maxEntrySize: LRUCache.Size\n  /**\n   * {@link LRUCache.OptionsBase.sizeCalculation}\n   */\n  sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n   */\n  noDeleteOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n   */\n  noDeleteOnStaleGet: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n   */\n  allowStaleOnFetchAbort: boolean\n  /**\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n   */\n  allowStaleOnFetchRejection: boolean\n  /**\n   * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n   */\n  ignoreFetchAbort: boolean\n\n  // computed properties\n  #size: LRUCache.Count\n  #calculatedSize: LRUCache.Size\n  #keyMap: Map<K, Index>\n  #keyList: (K | undefined)[]\n  #valList: (V | BackgroundFetch<V> | undefined)[]\n  #next: NumberArray\n  #prev: NumberArray\n  #head: Index\n  #tail: Index\n  #free: StackLike\n  #disposed?: DisposeTask<K, V>[]\n  #sizes?: ZeroArray\n  #starts?: ZeroArray\n  #ttls?: ZeroArray\n\n  #hasDispose: boolean\n  #hasFetchMethod: boolean\n  #hasDisposeAfter: boolean\n\n  /**\n   * Do not call this method unless you need to inspect the\n   * inner workings of the cache.  If anything returned by this\n   * object is modified in any way, strange breakage may occur.\n   *\n   * These fields are private for a reason!\n   *\n   * @internal\n   */\n  static unsafeExposeInternals<\n    K extends {},\n    V extends {},\n    FC extends unknown = unknown\n  >(c: LRUCache<K, V, FC>) {\n    return {\n      // properties\n      starts: c.#starts,\n      ttls: c.#ttls,\n      sizes: c.#sizes,\n      keyMap: c.#keyMap as Map<K, number>,\n      keyList: c.#keyList,\n      valList: c.#valList,\n      next: c.#next,\n      prev: c.#prev,\n      get head() {\n        return c.#head\n      },\n      get tail() {\n        return c.#tail\n      },\n      free: c.#free,\n      // methods\n      isBackgroundFetch: (p: any) => c.#isBackgroundFetch(p),\n      backgroundFetch: (\n        k: K,\n        index: number | undefined,\n        options: LRUCache.FetchOptions<K, V, FC>,\n        context: any\n      ): BackgroundFetch<V> =>\n        c.#backgroundFetch(\n          k,\n          index as Index | undefined,\n          options,\n          context\n        ),\n      moveToTail: (index: number): void =>\n        c.#moveToTail(index as Index),\n      indexes: (options?: { allowStale: boolean }) =>\n        c.#indexes(options),\n      rindexes: (options?: { allowStale: boolean }) =>\n        c.#rindexes(options),\n      isStale: (index: number | undefined) =>\n        c.#isStale(index as Index),\n    }\n  }\n\n  // Protected read-only members\n\n  /**\n   * {@link LRUCache.OptionsBase.max} (read-only)\n   */\n  get max(): LRUCache.Count {\n    return this.#max\n  }\n  /**\n   * {@link LRUCache.OptionsBase.maxSize} (read-only)\n   */\n  get maxSize(): LRUCache.Count {\n    return this.#maxSize\n  }\n  /**\n   * The total computed size of items in the cache (read-only)\n   */\n  get calculatedSize(): LRUCache.Size {\n    return this.#calculatedSize\n  }\n  /**\n   * The number of items stored in the cache (read-only)\n   */\n  get size(): LRUCache.Count {\n    return this.#size\n  }\n  /**\n   * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n   */\n  get fetchMethod(): LRUCache.Fetcher<K, V, FC> | undefined {\n    return this.#fetchMethod\n  }\n  get memoMethod(): LRUCache.Memoizer<K, V, FC> | undefined {\n    return this.#memoMethod\n  }\n  /**\n   * {@link LRUCache.OptionsBase.dispose} (read-only)\n   */\n  get dispose() {\n    return this.#dispose\n  }\n  /**\n   * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n   */\n  get disposeAfter() {\n    return this.#disposeAfter\n  }\n\n  constructor(\n    options: LRUCache.Options<K, V, FC> | LRUCache<K, V, FC>\n  ) {\n    const {\n      max = 0,\n      ttl,\n      ttlResolution = 1,\n      ttlAutopurge,\n      updateAgeOnGet,\n      updateAgeOnHas,\n      allowStale,\n      dispose,\n      disposeAfter,\n      noDisposeOnSet,\n      noUpdateTTL,\n      maxSize = 0,\n      maxEntrySize = 0,\n      sizeCalculation,\n      fetchMethod,\n      memoMethod,\n      noDeleteOnFetchRejection,\n      noDeleteOnStaleGet,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n    } = options\n\n    if (max !== 0 && !isPosInt(max)) {\n      throw new TypeError('max option must be a nonnegative integer')\n    }\n\n    const UintArray = max ? getUintArray(max) : Array\n    if (!UintArray) {\n      throw new Error('invalid max value: ' + max)\n    }\n\n    this.#max = max\n    this.#maxSize = maxSize\n    this.maxEntrySize = maxEntrySize || this.#maxSize\n    this.sizeCalculation = sizeCalculation\n    if (this.sizeCalculation) {\n      if (!this.#maxSize && !this.maxEntrySize) {\n        throw new TypeError(\n          'cannot set sizeCalculation without setting maxSize or maxEntrySize'\n        )\n      }\n      if (typeof this.sizeCalculation !== 'function') {\n        throw new TypeError('sizeCalculation set to non-function')\n      }\n    }\n\n    if (\n      memoMethod !== undefined &&\n      typeof memoMethod !== 'function'\n    ) {\n      throw new TypeError('memoMethod must be a function if defined')\n    }\n    this.#memoMethod = memoMethod\n\n    if (\n      fetchMethod !== undefined &&\n      typeof fetchMethod !== 'function'\n    ) {\n      throw new TypeError(\n        'fetchMethod must be a function if specified'\n      )\n    }\n    this.#fetchMethod = fetchMethod\n    this.#hasFetchMethod = !!fetchMethod\n\n    this.#keyMap = new Map()\n    this.#keyList = new Array(max).fill(undefined)\n    this.#valList = new Array(max).fill(undefined)\n    this.#next = new UintArray(max)\n    this.#prev = new UintArray(max)\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free = Stack.create(max)\n    this.#size = 0\n    this.#calculatedSize = 0\n\n    if (typeof dispose === 'function') {\n      this.#dispose = dispose\n    }\n    if (typeof disposeAfter === 'function') {\n      this.#disposeAfter = disposeAfter\n      this.#disposed = []\n    } else {\n      this.#disposeAfter = undefined\n      this.#disposed = undefined\n    }\n    this.#hasDispose = !!this.#dispose\n    this.#hasDisposeAfter = !!this.#disposeAfter\n\n    this.noDisposeOnSet = !!noDisposeOnSet\n    this.noUpdateTTL = !!noUpdateTTL\n    this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection\n    this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection\n    this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort\n    this.ignoreFetchAbort = !!ignoreFetchAbort\n\n    // NB: maxEntrySize is set to maxSize if it's set\n    if (this.maxEntrySize !== 0) {\n      if (this.#maxSize !== 0) {\n        if (!isPosInt(this.#maxSize)) {\n          throw new TypeError(\n            'maxSize must be a positive integer if specified'\n          )\n        }\n      }\n      if (!isPosInt(this.maxEntrySize)) {\n        throw new TypeError(\n          'maxEntrySize must be a positive integer if specified'\n        )\n      }\n      this.#initializeSizeTracking()\n    }\n\n    this.allowStale = !!allowStale\n    this.noDeleteOnStaleGet = !!noDeleteOnStaleGet\n    this.updateAgeOnGet = !!updateAgeOnGet\n    this.updateAgeOnHas = !!updateAgeOnHas\n    this.ttlResolution =\n      isPosInt(ttlResolution) || ttlResolution === 0\n        ? ttlResolution\n        : 1\n    this.ttlAutopurge = !!ttlAutopurge\n    this.ttl = ttl || 0\n    if (this.ttl) {\n      if (!isPosInt(this.ttl)) {\n        throw new TypeError(\n          'ttl must be a positive integer if specified'\n        )\n      }\n      this.#initializeTTLTracking()\n    }\n\n    // do not allow completely unbounded caches\n    if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n      throw new TypeError(\n        'At least one of max, maxSize, or ttl is required'\n      )\n    }\n    if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n      const code = 'LRU_CACHE_UNBOUNDED'\n      if (shouldWarn(code)) {\n        warned.add(code)\n        const msg =\n          'TTL caching without ttlAutopurge, max, or maxSize can ' +\n          'result in unbounded memory consumption.'\n        emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache)\n      }\n    }\n  }\n\n  /**\n   * Return the number of ms left in the item's TTL. If item is not in cache,\n   * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n   */\n  getRemainingTTL(key: K) {\n    return this.#keyMap.has(key) ? Infinity : 0\n  }\n\n  #initializeTTLTracking() {\n    const ttls = new ZeroArray(this.#max)\n    const starts = new ZeroArray(this.#max)\n    this.#ttls = ttls\n    this.#starts = starts\n\n    this.#setItemTTL = (index, ttl, start = perf.now()) => {\n      starts[index] = ttl !== 0 ? start : 0\n      ttls[index] = ttl\n      if (ttl !== 0 && this.ttlAutopurge) {\n        const t = setTimeout(() => {\n          if (this.#isStale(index)) {\n            this.#delete(this.#keyList[index] as K, 'expire')\n          }\n        }, ttl + 1)\n        // unref() not supported on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n    }\n\n    this.#updateItemAge = index => {\n      starts[index] = ttls[index] !== 0 ? perf.now() : 0\n    }\n\n    this.#statusTTL = (status, index) => {\n      if (ttls[index]) {\n        const ttl = ttls[index]\n        const start = starts[index]\n        /* c8 ignore next */\n        if (!ttl || !start) return\n        status.ttl = ttl\n        status.start = start\n        status.now = cachedNow || getNow()\n        const age = status.now - start\n        status.remainingTTL = ttl - age\n      }\n    }\n\n    // debounce calls to perf.now() to 1s so we're not hitting\n    // that costly call repeatedly.\n    let cachedNow = 0\n    const getNow = () => {\n      const n = perf.now()\n      if (this.ttlResolution > 0) {\n        cachedNow = n\n        const t = setTimeout(\n          () => (cachedNow = 0),\n          this.ttlResolution\n        )\n        // not available on all platforms\n        /* c8 ignore start */\n        if (t.unref) {\n          t.unref()\n        }\n        /* c8 ignore stop */\n      }\n      return n\n    }\n\n    this.getRemainingTTL = key => {\n      const index = this.#keyMap.get(key)\n      if (index === undefined) {\n        return 0\n      }\n      const ttl = ttls[index]\n      const start = starts[index]\n      if (!ttl || !start) {\n        return Infinity\n      }\n      const age = (cachedNow || getNow()) - start\n      return ttl - age\n    }\n\n    this.#isStale = index => {\n      const s = starts[index]\n      const t = ttls[index]\n      return !!t && !!s && (cachedNow || getNow()) - s > t\n    }\n  }\n\n  // conditionally set private methods related to TTL\n  #updateItemAge: (index: Index) => void = () => {}\n  #statusTTL: (status: LRUCache.Status<V>, index: Index) => void =\n    () => {}\n  #setItemTTL: (\n    index: Index,\n    ttl: LRUCache.Milliseconds,\n    start?: LRUCache.Milliseconds\n    // ignore because we never call this if we're not already in TTL mode\n    /* c8 ignore start */\n  ) => void = () => {}\n  /* c8 ignore stop */\n\n  #isStale: (index: Index) => boolean = () => false\n\n  #initializeSizeTracking() {\n    const sizes = new ZeroArray(this.#max)\n    this.#calculatedSize = 0\n    this.#sizes = sizes\n    this.#removeItemSize = index => {\n      this.#calculatedSize -= sizes[index] as number\n      sizes[index] = 0\n    }\n    this.#requireSize = (k, v, size, sizeCalculation) => {\n      // provisionally accept background fetches.\n      // actual value size will be checked when they return.\n      if (this.#isBackgroundFetch(v)) {\n        return 0\n      }\n      if (!isPosInt(size)) {\n        if (sizeCalculation) {\n          if (typeof sizeCalculation !== 'function') {\n            throw new TypeError('sizeCalculation must be a function')\n          }\n          size = sizeCalculation(v, k)\n          if (!isPosInt(size)) {\n            throw new TypeError(\n              'sizeCalculation return invalid (expect positive integer)'\n            )\n          }\n        } else {\n          throw new TypeError(\n            'invalid size value (must be positive integer). ' +\n              'When maxSize or maxEntrySize is used, sizeCalculation ' +\n              'or size must be set.'\n          )\n        }\n      }\n      return size\n    }\n    this.#addItemSize = (\n      index: Index,\n      size: LRUCache.Size,\n      status?: LRUCache.Status<V>\n    ) => {\n      sizes[index] = size\n      if (this.#maxSize) {\n        const maxSize = this.#maxSize - (sizes[index] as number)\n        while (this.#calculatedSize > maxSize) {\n          this.#evict(true)\n        }\n      }\n      this.#calculatedSize += sizes[index] as number\n      if (status) {\n        status.entrySize = size\n        status.totalCalculatedSize = this.#calculatedSize\n      }\n    }\n  }\n\n  #removeItemSize: (index: Index) => void = _i => {}\n  #addItemSize: (\n    index: Index,\n    size: LRUCache.Size,\n    status?: LRUCache.Status<V>\n  ) => void = (_i, _s, _st) => {}\n  #requireSize: (\n    k: K,\n    v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => LRUCache.Size = (\n    _k: K,\n    _v: V | BackgroundFetch<V>,\n    size?: LRUCache.Size,\n    sizeCalculation?: LRUCache.SizeCalculator<K, V>\n  ) => {\n    if (size || sizeCalculation) {\n      throw new TypeError(\n        'cannot set size without setting maxSize or maxEntrySize on cache'\n      )\n    }\n    return 0\n  };\n\n  *#indexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#tail; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#head) {\n          break\n        } else {\n          i = this.#prev[i] as Index\n        }\n      }\n    }\n  }\n\n  *#rindexes({ allowStale = this.allowStale } = {}) {\n    if (this.#size) {\n      for (let i = this.#head; true; ) {\n        if (!this.#isValidIndex(i)) {\n          break\n        }\n        if (allowStale || !this.#isStale(i)) {\n          yield i\n        }\n        if (i === this.#tail) {\n          break\n        } else {\n          i = this.#next[i] as Index\n        }\n      }\n    }\n  }\n\n  #isValidIndex(index: Index) {\n    return (\n      index !== undefined &&\n      this.#keyMap.get(this.#keyList[index] as K) === index\n    )\n  }\n\n  /**\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from most recently used to least recently used.\n   */\n  *entries() {\n    for (const i of this.#indexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]] as [K, V]\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.entries}\n   *\n   * Return a generator yielding `[key, value]` pairs,\n   * in order from least recently used to most recently used.\n   */\n  *rentries() {\n    for (const i of this.#rindexes()) {\n      if (\n        this.#valList[i] !== undefined &&\n        this.#keyList[i] !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield [this.#keyList[i], this.#valList[i]]\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the keys in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *keys() {\n    for (const i of this.#indexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.keys}\n   *\n   * Return a generator yielding the keys in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rkeys() {\n    for (const i of this.#rindexes()) {\n      const k = this.#keyList[i]\n      if (\n        k !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield k\n      }\n    }\n  }\n\n  /**\n   * Return a generator yielding the values in the cache,\n   * in order from most recently used to least recently used.\n   */\n  *values() {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i] as V\n      }\n    }\n  }\n\n  /**\n   * Inverse order version of {@link LRUCache.values}\n   *\n   * Return a generator yielding the values in the cache,\n   * in order from least recently used to most recently used.\n   */\n  *rvalues() {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      if (\n        v !== undefined &&\n        !this.#isBackgroundFetch(this.#valList[i])\n      ) {\n        yield this.#valList[i]\n      }\n    }\n  }\n\n  /**\n   * Iterating over the cache itself yields the same results as\n   * {@link LRUCache.entries}\n   */\n  [Symbol.iterator]() {\n    return this.entries()\n  }\n\n  /**\n   * A String value that is used in the creation of the default string\n   * description of an object. Called by the built-in method\n   * `Object.prototype.toString`.\n   */\n  [Symbol.toStringTag] = 'LRUCache'\n\n  /**\n   * Find a value for which the supplied fn method returns a truthy value,\n   * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n   */\n  find(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => boolean,\n    getOptions: LRUCache.GetOptions<K, V, FC> = {}\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      if (fn(value, this.#keyList[i] as K, this)) {\n        return this.get(this.#keyList[i] as K, getOptions)\n      }\n    }\n  }\n\n  /**\n   * Call the supplied function on each item in the cache, in order from most\n   * recently used to least recently used.\n   *\n   * `fn` is called as `fn(value, key, cache)`.\n   *\n   * If `thisp` is provided, function will be called in the `this`-context of\n   * the provided object, or the cache if no `thisp` object is provided.\n   *\n   * Does not update age or recenty of use, or iterate over stale values.\n   */\n  forEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#indexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * The same as {@link LRUCache.forEach} but items are iterated over in\n   * reverse order.  (ie, less recently used items are iterated over first.)\n   */\n  rforEach(\n    fn: (v: V, k: K, self: LRUCache<K, V, FC>) => any,\n    thisp: any = this\n  ) {\n    for (const i of this.#rindexes()) {\n      const v = this.#valList[i]\n      const value = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined) continue\n      fn.call(thisp, value, this.#keyList[i] as K, this)\n    }\n  }\n\n  /**\n   * Delete any stale entries. Returns true if anything was removed,\n   * false otherwise.\n   */\n  purgeStale() {\n    let deleted = false\n    for (const i of this.#rindexes({ allowStale: true })) {\n      if (this.#isStale(i)) {\n        this.#delete(this.#keyList[i] as K, 'expire')\n        deleted = true\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Get the extended info about a given entry, to get its value, size, and\n   * TTL info simultaneously. Returns `undefined` if the key is not present.\n   *\n   * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n   * serialization, the `start` value is always the current timestamp, and the\n   * `ttl` is a calculated remaining time to live (negative if expired).\n   *\n   * Always returns stale values, if their info is found in the cache, so be\n   * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n   * if relevant.\n   */\n  info(key: K): LRUCache.Entry<V> | undefined {\n    const i = this.#keyMap.get(key)\n    if (i === undefined) return undefined\n    const v = this.#valList[i]\n    const value: V | undefined = this.#isBackgroundFetch(v)\n      ? v.__staleWhileFetching\n      : v\n    if (value === undefined) return undefined\n    const entry: LRUCache.Entry<V> = { value }\n    if (this.#ttls && this.#starts) {\n      const ttl = this.#ttls[i]\n      const start = this.#starts[i]\n      if (ttl && start) {\n        const remain = ttl - (perf.now() - start)\n        entry.ttl = remain\n        entry.start = Date.now()\n      }\n    }\n    if (this.#sizes) {\n      entry.size = this.#sizes[i]\n    }\n    return entry\n  }\n\n  /**\n   * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n   * passed to {@link LRLUCache#load}.\n   *\n   * The `start` fields are calculated relative to a portable `Date.now()`\n   * timestamp, even if `performance.now()` is available.\n   *\n   * Stale entries are always included in the `dump`, even if\n   * {@link LRUCache.OptionsBase.allowStale} is false.\n   *\n   * Note: this returns an actual array, not a generator, so it can be more\n   * easily passed around.\n   */\n  dump() {\n    const arr: [K, LRUCache.Entry<V>][] = []\n    for (const i of this.#indexes({ allowStale: true })) {\n      const key = this.#keyList[i]\n      const v = this.#valList[i]\n      const value: V | undefined = this.#isBackgroundFetch(v)\n        ? v.__staleWhileFetching\n        : v\n      if (value === undefined || key === undefined) continue\n      const entry: LRUCache.Entry<V> = { value }\n      if (this.#ttls && this.#starts) {\n        entry.ttl = this.#ttls[i]\n        // always dump the start relative to a portable timestamp\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = perf.now() - (this.#starts[i] as number)\n        entry.start = Math.floor(Date.now() - age)\n      }\n      if (this.#sizes) {\n        entry.size = this.#sizes[i]\n      }\n      arr.unshift([key, entry])\n    }\n    return arr\n  }\n\n  /**\n   * Reset the cache and load in the items in entries in the order listed.\n   *\n   * The shape of the resulting cache may be different if the same options are\n   * not used in both caches.\n   *\n   * The `start` fields are assumed to be calculated relative to a portable\n   * `Date.now()` timestamp, even if `performance.now()` is available.\n   */\n  load(arr: [K, LRUCache.Entry<V>][]) {\n    this.clear()\n    for (const [key, entry] of arr) {\n      if (entry.start) {\n        // entry.start is a portable timestamp, but we may be using\n        // node's performance.now(), so calculate the offset, so that\n        // we get the intended remaining TTL, no matter how long it's\n        // been on ice.\n        //\n        // it's ok for this to be a bit slow, it's a rare operation.\n        const age = Date.now() - entry.start\n        entry.start = perf.now() - age\n      }\n      this.set(key, entry.value, entry)\n    }\n  }\n\n  /**\n   * Add a value to the cache.\n   *\n   * Note: if `undefined` is specified as a value, this is an alias for\n   * {@link LRUCache#delete}\n   *\n   * Fields on the {@link LRUCache.SetOptions} options param will override\n   * their corresponding values in the constructor options for the scope\n   * of this single `set()` operation.\n   *\n   * If `start` is provided, then that will set the effective start\n   * time for the TTL calculation. Note that this must be a previous\n   * value of `performance.now()` if supported, or a previous value of\n   * `Date.now()` if not.\n   *\n   * Options object may also include `size`, which will prevent\n   * calling the `sizeCalculation` function and just use the specified\n   * number if it is a positive integer, and `noDisposeOnSet` which\n   * will prevent calling a `dispose` function in the case of\n   * overwrites.\n   *\n   * If the `size` (or return value of `sizeCalculation`) for a given\n   * entry is greater than `maxEntrySize`, then the item will not be\n   * added to the cache.\n   *\n   * Will update the recency of the entry.\n   *\n   * If the value is `undefined`, then this is an alias for\n   * `cache.delete(key)`. `undefined` is never stored in the cache.\n   */\n  set(\n    k: K,\n    v: V | BackgroundFetch<V> | undefined,\n    setOptions: LRUCache.SetOptions<K, V, FC> = {}\n  ) {\n    if (v === undefined) {\n      this.delete(k)\n      return this\n    }\n    const {\n      ttl = this.ttl,\n      start,\n      noDisposeOnSet = this.noDisposeOnSet,\n      sizeCalculation = this.sizeCalculation,\n      status,\n    } = setOptions\n    let { noUpdateTTL = this.noUpdateTTL } = setOptions\n\n    const size = this.#requireSize(\n      k,\n      v,\n      setOptions.size || 0,\n      sizeCalculation\n    )\n    // if the item doesn't fit, don't do anything\n    // NB: maxEntrySize set to maxSize by default\n    if (this.maxEntrySize && size > this.maxEntrySize) {\n      if (status) {\n        status.set = 'miss'\n        status.maxEntrySizeExceeded = true\n      }\n      // have to delete, in case something is there already.\n      this.#delete(k, 'set')\n      return this\n    }\n    let index = this.#size === 0 ? undefined : this.#keyMap.get(k)\n    if (index === undefined) {\n      // addition\n      index = (\n        this.#size === 0\n          ? this.#tail\n          : this.#free.length !== 0\n          ? this.#free.pop()\n          : this.#size === this.#max\n          ? this.#evict(false)\n          : this.#size\n      ) as Index\n      this.#keyList[index] = k\n      this.#valList[index] = v\n      this.#keyMap.set(k, index)\n      this.#next[this.#tail] = index\n      this.#prev[index] = this.#tail\n      this.#tail = index\n      this.#size++\n      this.#addItemSize(index, size, status)\n      if (status) status.set = 'add'\n      noUpdateTTL = false\n    } else {\n      // update\n      this.#moveToTail(index)\n      const oldVal = this.#valList[index] as V | BackgroundFetch<V>\n      if (v !== oldVal) {\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n          oldVal.__abortController.abort(new Error('replaced'))\n          const { __staleWhileFetching: s } = oldVal\n          if (s !== undefined && !noDisposeOnSet) {\n            if (this.#hasDispose) {\n              this.#dispose?.(s as V, k, 'set')\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([s as V, k, 'set'])\n            }\n          }\n        } else if (!noDisposeOnSet) {\n          if (this.#hasDispose) {\n            this.#dispose?.(oldVal as V, k, 'set')\n          }\n          if (this.#hasDisposeAfter) {\n            this.#disposed?.push([oldVal as V, k, 'set'])\n          }\n        }\n        this.#removeItemSize(index)\n        this.#addItemSize(index, size, status)\n        this.#valList[index] = v\n        if (status) {\n          status.set = 'replace'\n          const oldValue =\n            oldVal && this.#isBackgroundFetch(oldVal)\n              ? oldVal.__staleWhileFetching\n              : oldVal\n          if (oldValue !== undefined) status.oldValue = oldValue\n        }\n      } else if (status) {\n        status.set = 'update'\n      }\n    }\n    if (ttl !== 0 && !this.#ttls) {\n      this.#initializeTTLTracking()\n    }\n    if (this.#ttls) {\n      if (!noUpdateTTL) {\n        this.#setItemTTL(index, ttl, start)\n      }\n      if (status) this.#statusTTL(status, index)\n    }\n    if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return this\n  }\n\n  /**\n   * Evict the least recently used item, returning its value or\n   * `undefined` if cache is empty.\n   */\n  pop(): V | undefined {\n    try {\n      while (this.#size) {\n        const val = this.#valList[this.#head]\n        this.#evict(true)\n        if (this.#isBackgroundFetch(val)) {\n          if (val.__staleWhileFetching) {\n            return val.__staleWhileFetching\n          }\n        } else if (val !== undefined) {\n          return val\n        }\n      }\n    } finally {\n      if (this.#hasDisposeAfter && this.#disposed) {\n        const dt = this.#disposed\n        let task: DisposeTask<K, V> | undefined\n        while ((task = dt?.shift())) {\n          this.#disposeAfter?.(...task)\n        }\n      }\n    }\n  }\n\n  #evict(free: boolean) {\n    const head = this.#head\n    const k = this.#keyList[head] as K\n    const v = this.#valList[head] as V\n    if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n      v.__abortController.abort(new Error('evicted'))\n    } else if (this.#hasDispose || this.#hasDisposeAfter) {\n      if (this.#hasDispose) {\n        this.#dispose?.(v, k, 'evict')\n      }\n      if (this.#hasDisposeAfter) {\n        this.#disposed?.push([v, k, 'evict'])\n      }\n    }\n    this.#removeItemSize(head)\n    // if we aren't about to use the index, then null these out\n    if (free) {\n      this.#keyList[head] = undefined\n      this.#valList[head] = undefined\n      this.#free.push(head)\n    }\n    if (this.#size === 1) {\n      this.#head = this.#tail = 0 as Index\n      this.#free.length = 0\n    } else {\n      this.#head = this.#next[head] as Index\n    }\n    this.#keyMap.delete(k)\n    this.#size--\n    return head\n  }\n\n  /**\n   * Check if a key is in the cache, without updating the recency of use.\n   * Will return false if the item is stale, even though it is technically\n   * in the cache.\n   *\n   * Check if a key is in the cache, without updating the recency of\n   * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n   * to `true` in either the options or the constructor.\n   *\n   * Will return `false` if the item is stale, even though it is technically in\n   * the cache. The difference can be determined (if it matters) by using a\n   * `status` argument, and inspecting the `has` field.\n   *\n   * Will not update item age unless\n   * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n   */\n  has(k: K, hasOptions: LRUCache.HasOptions<K, V, FC> = {}) {\n    const { updateAgeOnHas = this.updateAgeOnHas, status } =\n      hasOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const v = this.#valList[index]\n      if (\n        this.#isBackgroundFetch(v) &&\n        v.__staleWhileFetching === undefined\n      ) {\n        return false\n      }\n      if (!this.#isStale(index)) {\n        if (updateAgeOnHas) {\n          this.#updateItemAge(index)\n        }\n        if (status) {\n          status.has = 'hit'\n          this.#statusTTL(status, index)\n        }\n        return true\n      } else if (status) {\n        status.has = 'stale'\n        this.#statusTTL(status, index)\n      }\n    } else if (status) {\n      status.has = 'miss'\n    }\n    return false\n  }\n\n  /**\n   * Like {@link LRUCache#get} but doesn't update recency or delete stale\n   * items.\n   *\n   * Returns `undefined` if the item is stale, unless\n   * {@link LRUCache.OptionsBase.allowStale} is set.\n   */\n  peek(k: K, peekOptions: LRUCache.PeekOptions<K, V, FC> = {}) {\n    const { allowStale = this.allowStale } = peekOptions\n    const index = this.#keyMap.get(k)\n    if (\n      index === undefined ||\n      (!allowStale && this.#isStale(index))\n    ) {\n      return\n    }\n    const v = this.#valList[index]\n    // either stale and allowed, or forcing a refresh of non-stale value\n    return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v\n  }\n\n  #backgroundFetch(\n    k: K,\n    index: Index | undefined,\n    options: LRUCache.FetchOptions<K, V, FC>,\n    context: any\n  ): BackgroundFetch<V> {\n    const v = index === undefined ? undefined : this.#valList[index]\n    if (this.#isBackgroundFetch(v)) {\n      return v\n    }\n\n    const ac = new AC()\n    const { signal } = options\n    // when/if our AC signals, then stop listening to theirs.\n    signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n      signal: ac.signal,\n    })\n\n    const fetchOpts = {\n      signal: ac.signal,\n      options,\n      context,\n    }\n\n    const cb = (\n      v: V | undefined,\n      updateCache = false\n    ): V | undefined => {\n      const { aborted } = ac.signal\n      const ignoreAbort = options.ignoreFetchAbort && v !== undefined\n      if (options.status) {\n        if (aborted && !updateCache) {\n          options.status.fetchAborted = true\n          options.status.fetchError = ac.signal.reason\n          if (ignoreAbort) options.status.fetchAbortIgnored = true\n        } else {\n          options.status.fetchResolved = true\n        }\n      }\n      if (aborted && !ignoreAbort && !updateCache) {\n        return fetchFail(ac.signal.reason)\n      }\n      // either we didn't abort, and are still here, or we did, and ignored\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        if (v === undefined) {\n          if (bf.__staleWhileFetching) {\n            this.#valList[index as Index] = bf.__staleWhileFetching\n          } else {\n            this.#delete(k, 'fetch')\n          }\n        } else {\n          if (options.status) options.status.fetchUpdated = true\n          this.set(k, v, fetchOpts.options)\n        }\n      }\n      return v\n    }\n\n    const eb = (er: any) => {\n      if (options.status) {\n        options.status.fetchRejected = true\n        options.status.fetchError = er\n      }\n      return fetchFail(er)\n    }\n\n    const fetchFail = (er: any): V | undefined => {\n      const { aborted } = ac.signal\n      const allowStaleAborted =\n        aborted && options.allowStaleOnFetchAbort\n      const allowStale =\n        allowStaleAborted || options.allowStaleOnFetchRejection\n      const noDelete = allowStale || options.noDeleteOnFetchRejection\n      const bf = p as BackgroundFetch<V>\n      if (this.#valList[index as Index] === p) {\n        // if we allow stale on fetch rejections, then we need to ensure that\n        // the stale value is not removed from the cache when the fetch fails.\n        const del = !noDelete || bf.__staleWhileFetching === undefined\n        if (del) {\n          this.#delete(k, 'fetch')\n        } else if (!allowStaleAborted) {\n          // still replace the *promise* with the stale value,\n          // since we are done with the promise at this point.\n          // leave it untouched if we're still waiting for an\n          // aborted background fetch that hasn't yet returned.\n          this.#valList[index as Index] = bf.__staleWhileFetching\n        }\n      }\n      if (allowStale) {\n        if (options.status && bf.__staleWhileFetching !== undefined) {\n          options.status.returnedStale = true\n        }\n        return bf.__staleWhileFetching\n      } else if (bf.__returned === bf) {\n        throw er\n      }\n    }\n\n    const pcall = (\n      res: (v: V | undefined) => void,\n      rej: (e: any) => void\n    ) => {\n      const fmp = this.#fetchMethod?.(k, v, fetchOpts)\n      if (fmp && fmp instanceof Promise) {\n        fmp.then(v => res(v === undefined ? undefined : v), rej)\n      }\n      // ignored, we go until we finish, regardless.\n      // defer check until we are actually aborting,\n      // so fetchMethod can override.\n      ac.signal.addEventListener('abort', () => {\n        if (\n          !options.ignoreFetchAbort ||\n          options.allowStaleOnFetchAbort\n        ) {\n          res(undefined)\n          // when it eventually resolves, update the cache.\n          if (options.allowStaleOnFetchAbort) {\n            res = v => cb(v, true)\n          }\n        }\n      })\n    }\n\n    if (options.status) options.status.fetchDispatched = true\n    const p = new Promise(pcall).then(cb, eb)\n    const bf: BackgroundFetch<V> = Object.assign(p, {\n      __abortController: ac,\n      __staleWhileFetching: v,\n      __returned: undefined,\n    })\n\n    if (index === undefined) {\n      // internal, don't expose status.\n      this.set(k, bf, { ...fetchOpts.options, status: undefined })\n      index = this.#keyMap.get(k)\n    } else {\n      this.#valList[index] = bf\n    }\n    return bf\n  }\n\n  #isBackgroundFetch(p: any): p is BackgroundFetch<V> {\n    if (!this.#hasFetchMethod) return false\n    const b = p as BackgroundFetch<V>\n    return (\n      !!b &&\n      b instanceof Promise &&\n      b.hasOwnProperty('__staleWhileFetching') &&\n      b.__abortController instanceof AC\n    )\n  }\n\n  /**\n   * Make an asynchronous cached fetch using the\n   * {@link LRUCache.OptionsBase.fetchMethod} function.\n   *\n   * If the value is in the cache and not stale, then the returned\n   * Promise resolves to the value.\n   *\n   * If not in the cache, or beyond its TTL staleness, then\n   * `fetchMethod(key, staleValue, { options, signal, context })` is\n   * called, and the value returned will be added to the cache once\n   * resolved.\n   *\n   * If called with `allowStale`, and an asynchronous fetch is\n   * currently in progress to reload a stale value, then the former\n   * stale value will be returned.\n   *\n   * If called with `forceRefresh`, then the cached item will be\n   * re-fetched, even if it is not stale. However, if `allowStale` is also\n   * set, then the old value will still be returned. This is useful\n   * in cases where you want to force a reload of a cached value. If\n   * a background fetch is already in progress, then `forceRefresh`\n   * has no effect.\n   *\n   * If multiple fetches for the same key are issued, then they will all be\n   * coalesced into a single call to fetchMethod.\n   *\n   * Note that this means that handling options such as\n   * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort},\n   * {@link LRUCache.FetchOptions.signal},\n   * and {@link LRUCache.OptionsBase.allowStaleOnFetchRejection} will be\n   * determined by the FIRST fetch() call for a given key.\n   *\n   * This is a known (fixable) shortcoming which will be addresed on when\n   * someone complains about it, as the fix would involve added complexity and\n   * may not be worth the costs for this edge case.\n   *\n   * If {@link LRUCache.OptionsBase.fetchMethod} is not specified, then this is\n   * effectively an alias for `Promise.resolve(cache.get(key))`.\n   *\n   * When the fetch method resolves to a value, if the fetch has not\n   * been aborted due to deletion, eviction, or being overwritten,\n   * then it is added to the cache using the options provided.\n   *\n   * If the key is evicted or deleted before the `fetchMethod`\n   * resolves, then the AbortSignal passed to the `fetchMethod` will\n   * receive an `abort` event, and the promise returned by `fetch()`\n   * will reject with the reason for the abort.\n   *\n   * If a `signal` is passed to the `fetch()` call, then aborting the\n   * signal will abort the fetch and cause the `fetch()` promise to\n   * reject with the reason provided.\n   *\n   * **Setting `context`**\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the {@link LRUCache} constructor, then all\n   * calls to `cache.fetch()` _must_ provide a `context` option. If\n   * set to `undefined` or `void`, then calls to fetch _must not_\n   * provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that\n   * might be relevant in the course of fetching the data. It is only\n   * relevant for the course of a single `fetch()` operation, and\n   * discarded afterwards.\n   *\n   * **Note: `fetch()` calls are inflight-unique**\n   *\n   * If you call `fetch()` multiple times with the same key value,\n   * then every call after the first will resolve on the same\n   * promise<sup>1</sup>,\n   * _even if they have different settings that would otherwise change\n   * the behavior of the fetch_, such as `noDeleteOnFetchRejection`\n   * or `ignoreFetchAbort`.\n   *\n   * In most cases, this is not a problem (in fact, only fetching\n   * something once is what you probably want, if you're caching in\n   * the first place). If you are changing the fetch() options\n   * dramatically between runs, there's a good chance that you might\n   * be trying to fit divergent semantics into a single object, and\n   * would be better off with multiple cache instances.\n   *\n   * **1**: Ie, they're not the \"same Promise\", but they resolve at\n   * the same time, because they're both waiting on the same\n   * underlying fetchMethod response.\n   */\n\n  fetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<undefined | V>\n\n  // this overload not allowed if context is required\n  fetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<undefined | V>\n\n  async fetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<undefined | V> {\n    const {\n      // get options\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      // set options\n      ttl = this.ttl,\n      noDisposeOnSet = this.noDisposeOnSet,\n      size = 0,\n      sizeCalculation = this.sizeCalculation,\n      noUpdateTTL = this.noUpdateTTL,\n      // fetch exclusive options\n      noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,\n      ignoreFetchAbort = this.ignoreFetchAbort,\n      allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,\n      context,\n      forceRefresh = false,\n      status,\n      signal,\n    } = fetchOptions\n\n    if (!this.#hasFetchMethod) {\n      if (status) status.fetch = 'get'\n      return this.get(k, {\n        allowStale,\n        updateAgeOnGet,\n        noDeleteOnStaleGet,\n        status,\n      })\n    }\n\n    const options = {\n      allowStale,\n      updateAgeOnGet,\n      noDeleteOnStaleGet,\n      ttl,\n      noDisposeOnSet,\n      size,\n      sizeCalculation,\n      noUpdateTTL,\n      noDeleteOnFetchRejection,\n      allowStaleOnFetchRejection,\n      allowStaleOnFetchAbort,\n      ignoreFetchAbort,\n      status,\n      signal,\n    }\n\n    let index = this.#keyMap.get(k)\n    if (index === undefined) {\n      if (status) status.fetch = 'miss'\n      const p = this.#backgroundFetch(k, index, options, context)\n      return (p.__returned = p)\n    } else {\n      // in cache, maybe already fetching\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        const stale =\n          allowStale && v.__staleWhileFetching !== undefined\n        if (status) {\n          status.fetch = 'inflight'\n          if (stale) status.returnedStale = true\n        }\n        return stale ? v.__staleWhileFetching : (v.__returned = v)\n      }\n\n      // if we force a refresh, that means do NOT serve the cached value,\n      // unless we are already in the process of refreshing the cache.\n      const isStale = this.#isStale(index)\n      if (!forceRefresh && !isStale) {\n        if (status) status.fetch = 'hit'\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        if (status) this.#statusTTL(status, index)\n        return v\n      }\n\n      // ok, it is stale or a forced refresh, and not already fetching.\n      // refresh the cache.\n      const p = this.#backgroundFetch(k, index, options, context)\n      const hasStale = p.__staleWhileFetching !== undefined\n      const staleVal = hasStale && allowStale\n      if (status) {\n        status.fetch = isStale ? 'stale' : 'refresh'\n        if (staleVal && isStale) status.returnedStale = true\n      }\n      return staleVal ? p.__staleWhileFetching : (p.__returned = p)\n    }\n  }\n\n  /**\n   * In some cases, `cache.fetch()` may resolve to `undefined`, either because\n   * a {@link LRUCache.OptionsBase#fetchMethod} was not provided (turning\n   * `cache.fetch(k)` into just an async wrapper around `cache.get(k)`) or\n   * because `ignoreFetchAbort` was specified (either to the constructor or\n   * in the {@link LRUCache.FetchOptions}). Also, the\n   * {@link OptionsBase.fetchMethod} may return `undefined` or `void`, making\n   * the test even more complicated.\n   *\n   * Because inferring the cases where `undefined` might be returned are so\n   * cumbersome, but testing for `undefined` can also be annoying, this method\n   * can be used, which will reject if `this.fetch()` resolves to undefined.\n   */\n  forceFetch(\n    k: K,\n    fetchOptions: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : LRUCache.FetchOptionsWithContext<K, V, FC>\n  ): Promise<V>\n  // this overload not allowed if context is required\n  forceFetch(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    fetchOptions?: unknown extends FC\n      ? LRUCache.FetchOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.FetchOptionsNoContext<K, V>\n      : never\n  ): Promise<V>\n  async forceFetch(\n    k: K,\n    fetchOptions: LRUCache.FetchOptions<K, V, FC> = {}\n  ): Promise<V> {\n    const v = await this.fetch(\n      k,\n      fetchOptions as unknown extends FC\n        ? LRUCache.FetchOptions<K, V, FC>\n        : FC extends undefined | void\n        ? LRUCache.FetchOptionsNoContext<K, V>\n        : LRUCache.FetchOptionsWithContext<K, V, FC>\n    )\n    if (v === undefined) throw new Error('fetch() returned undefined')\n    return v\n  }\n\n  /**\n   * If the key is found in the cache, then this is equivalent to\n   * {@link LRUCache#get}. If not, in the cache, then calculate the value using\n   * the {@link LRUCache.OptionsBase.memoMethod}, and add it to the cache.\n   *\n   * If an `FC` type is set to a type other than `unknown`, `void`, or\n   * `undefined` in the LRUCache constructor, then all calls to `cache.memo()`\n   * _must_ provide a `context` option. If set to `undefined` or `void`, then\n   * calls to memo _must not_ provide a `context` option.\n   *\n   * The `context` param allows you to provide arbitrary data that might be\n   * relevant in the course of fetching the data. It is only relevant for the\n   * course of a single `memo()` operation, and discarded afterwards.\n   */\n  memo(\n    k: K,\n    memoOptions: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : LRUCache.MemoOptionsWithContext<K, V, FC>\n  ): V\n  // this overload not allowed if context is required\n  memo(\n    k: unknown extends FC\n      ? K\n      : FC extends undefined | void\n      ? K\n      : never,\n    memoOptions?: unknown extends FC\n      ? LRUCache.MemoOptions<K, V, FC>\n      : FC extends undefined | void\n      ? LRUCache.MemoOptionsNoContext<K, V>\n      : never\n  ): V\n  memo(k: K, memoOptions: LRUCache.MemoOptions<K, V, FC> = {}) {\n    const memoMethod = this.#memoMethod\n    if (!memoMethod) {\n      throw new Error('no memoMethod provided to constructor')\n    }\n    const { context, forceRefresh, ...options } = memoOptions\n    const v = this.get(k, options)\n    if (!forceRefresh && v !== undefined) return v\n    const vv = memoMethod(k, v, {\n      options,\n      context,\n    } as LRUCache.MemoizerOptions<K, V, FC>)\n    this.set(k, vv, options)\n    return vv\n  }\n\n  /**\n   * Return a value from the cache. Will update the recency of the cache\n   * entry found.\n   *\n   * If the key is not found, get() will return `undefined`.\n   */\n  get(k: K, getOptions: LRUCache.GetOptions<K, V, FC> = {}) {\n    const {\n      allowStale = this.allowStale,\n      updateAgeOnGet = this.updateAgeOnGet,\n      noDeleteOnStaleGet = this.noDeleteOnStaleGet,\n      status,\n    } = getOptions\n    const index = this.#keyMap.get(k)\n    if (index !== undefined) {\n      const value = this.#valList[index]\n      const fetching = this.#isBackgroundFetch(value)\n      if (status) this.#statusTTL(status, index)\n      if (this.#isStale(index)) {\n        if (status) status.get = 'stale'\n        // delete only if not an in-flight background fetch\n        if (!fetching) {\n          if (!noDeleteOnStaleGet) {\n            this.#delete(k, 'expire')\n          }\n          if (status && allowStale) status.returnedStale = true\n          return allowStale ? value : undefined\n        } else {\n          if (\n            status &&\n            allowStale &&\n            value.__staleWhileFetching !== undefined\n          ) {\n            status.returnedStale = true\n          }\n          return allowStale ? value.__staleWhileFetching : undefined\n        }\n      } else {\n        if (status) status.get = 'hit'\n        // if we're currently fetching it, we don't actually have it yet\n        // it's not stale, which means this isn't a staleWhileRefetching.\n        // If it's not stale, and fetching, AND has a __staleWhileFetching\n        // value, then that means the user fetched with {forceRefresh:true},\n        // so it's safe to return that value.\n        if (fetching) {\n          return value.__staleWhileFetching\n        }\n        this.#moveToTail(index)\n        if (updateAgeOnGet) {\n          this.#updateItemAge(index)\n        }\n        return value\n      }\n    } else if (status) {\n      status.get = 'miss'\n    }\n  }\n\n  #connect(p: Index, n: Index) {\n    this.#prev[n] = p\n    this.#next[p] = n\n  }\n\n  #moveToTail(index: Index): void {\n    // if tail already, nothing to do\n    // if head, move head to next[index]\n    // else\n    //   move next[prev[index]] to next[index] (head has no prev)\n    //   move prev[next[index]] to prev[index]\n    // prev[index] = tail\n    // next[tail] = index\n    // tail = index\n    if (index !== this.#tail) {\n      if (index === this.#head) {\n        this.#head = this.#next[index] as Index\n      } else {\n        this.#connect(\n          this.#prev[index] as Index,\n          this.#next[index] as Index\n        )\n      }\n      this.#connect(this.#tail, index)\n      this.#tail = index\n    }\n  }\n\n  /**\n   * Deletes a key out of the cache.\n   *\n   * Returns true if the key was deleted, false otherwise.\n   */\n  delete(k: K) {\n    return this.#delete(k, 'delete')\n  }\n\n  #delete(k: K, reason: LRUCache.DisposeReason) {\n    let deleted = false\n    if (this.#size !== 0) {\n      const index = this.#keyMap.get(k)\n      if (index !== undefined) {\n        deleted = true\n        if (this.#size === 1) {\n          this.#clear(reason)\n        } else {\n          this.#removeItemSize(index)\n          const v = this.#valList[index]\n          if (this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('deleted'))\n          } else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n              this.#dispose?.(v as V, k, reason)\n            }\n            if (this.#hasDisposeAfter) {\n              this.#disposed?.push([v as V, k, reason])\n            }\n          }\n          this.#keyMap.delete(k)\n          this.#keyList[index] = undefined\n          this.#valList[index] = undefined\n          if (index === this.#tail) {\n            this.#tail = this.#prev[index] as Index\n          } else if (index === this.#head) {\n            this.#head = this.#next[index] as Index\n          } else {\n            const pi = this.#prev[index] as number\n            this.#next[pi] = this.#next[index] as number\n            const ni = this.#next[index] as number\n            this.#prev[ni] = this.#prev[index] as number\n          }\n          this.#size--\n          this.#free.push(index)\n        }\n      }\n    }\n    if (this.#hasDisposeAfter && this.#disposed?.length) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n    return deleted\n  }\n\n  /**\n   * Clear the cache entirely, throwing away all values.\n   */\n  clear() {\n    return this.#clear('delete')\n  }\n  #clear(reason: LRUCache.DisposeReason) {\n    for (const index of this.#rindexes({ allowStale: true })) {\n      const v = this.#valList[index]\n      if (this.#isBackgroundFetch(v)) {\n        v.__abortController.abort(new Error('deleted'))\n      } else {\n        const k = this.#keyList[index]\n        if (this.#hasDispose) {\n          this.#dispose?.(v as V, k as K, reason)\n        }\n        if (this.#hasDisposeAfter) {\n          this.#disposed?.push([v as V, k as K, reason])\n        }\n      }\n    }\n\n    this.#keyMap.clear()\n    this.#valList.fill(undefined)\n    this.#keyList.fill(undefined)\n    if (this.#ttls && this.#starts) {\n      this.#ttls.fill(0)\n      this.#starts.fill(0)\n    }\n    if (this.#sizes) {\n      this.#sizes.fill(0)\n    }\n    this.#head = 0 as Index\n    this.#tail = 0 as Index\n    this.#free.length = 0\n    this.#calculatedSize = 0\n    this.#size = 0\n    if (this.#hasDisposeAfter && this.#disposed) {\n      const dt = this.#disposed\n      let task: DisposeTask<K, V> | undefined\n      while ((task = dt?.shift())) {\n        this.#disposeAfter?.(...task)\n      }\n    }\n  }\n}\n", "export function utf8Count(str: string): number {\n  const strLength = str.length;\n\n  let byteLength = 0;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      byteLength++;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      byteLength += 2;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        byteLength += 3;\n      } else {\n        // 4-byte\n        byteLength += 4;\n      }\n    }\n  }\n  return byteLength;\n}\n\nexport function utf8EncodeJs(str: string, output: Uint8Array, outputOffset: number): void {\n  const strLength = str.length;\n  let offset = outputOffset;\n  let pos = 0;\n  while (pos < strLength) {\n    let value = str.charCodeAt(pos++);\n\n    if ((value & 0xffffff80) === 0) {\n      // 1-byte\n      output[offset++] = value;\n      continue;\n    } else if ((value & 0xfffff800) === 0) {\n      // 2-bytes\n      output[offset++] = ((value >> 6) & 0x1f) | 0xc0;\n    } else {\n      // handle surrogate pair\n      if (value >= 0xd800 && value <= 0xdbff) {\n        // high surrogate\n        if (pos < strLength) {\n          const extra = str.charCodeAt(pos);\n          if ((extra & 0xfc00) === 0xdc00) {\n            ++pos;\n            value = ((value & 0x3ff) << 10) + (extra & 0x3ff) + 0x10000;\n          }\n        }\n      }\n\n      if ((value & 0xffff0000) === 0) {\n        // 3-byte\n        output[offset++] = ((value >> 12) & 0x0f) | 0xe0;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      } else {\n        // 4-byte\n        output[offset++] = ((value >> 18) & 0x07) | 0xf0;\n        output[offset++] = ((value >> 12) & 0x3f) | 0x80;\n        output[offset++] = ((value >> 6) & 0x3f) | 0x80;\n      }\n    }\n\n    output[offset++] = (value & 0x3f) | 0x80;\n  }\n}\n\n// TextEncoder and TextDecoder are standardized in whatwg encoding:\n// https://encoding.spec.whatwg.org/\n// and available in all the modern browsers:\n// https://caniuse.com/textencoder\n// They are available in Node.js since v12 LTS as well:\n// https://nodejs.org/api/globals.html#textencoder\n\nconst sharedTextEncoder = new TextEncoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/encode-string.ts` for details.\nconst TEXT_ENCODER_THRESHOLD = 50;\n\nexport function utf8EncodeTE(str: string, output: Uint8Array, outputOffset: number): void {\n  sharedTextEncoder.encodeInto(str, output.subarray(outputOffset));\n}\n\nexport function utf8Encode(str: string, output: Uint8Array, outputOffset: number): void {\n  if (str.length > TEXT_ENCODER_THRESHOLD) {\n    utf8EncodeTE(str, output, outputOffset);\n  } else {\n    utf8EncodeJs(str, output, outputOffset);\n  }\n}\n\nconst CHUNK_SIZE = 0x1_000;\n\nexport function utf8DecodeJs(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  let offset = inputOffset;\n  const end = offset + byteLength;\n\n  const units: Array<number> = [];\n  let result = \"\";\n  while (offset < end) {\n    const byte1 = bytes[offset++]!;\n    if ((byte1 & 0x80) === 0) {\n      // 1 byte\n      units.push(byte1);\n    } else if ((byte1 & 0xe0) === 0xc0) {\n      // 2 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 6) | byte2);\n    } else if ((byte1 & 0xf0) === 0xe0) {\n      // 3 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      units.push(((byte1 & 0x1f) << 12) | (byte2 << 6) | byte3);\n    } else if ((byte1 & 0xf8) === 0xf0) {\n      // 4 bytes\n      const byte2 = bytes[offset++]! & 0x3f;\n      const byte3 = bytes[offset++]! & 0x3f;\n      const byte4 = bytes[offset++]! & 0x3f;\n      let unit = ((byte1 & 0x07) << 0x12) | (byte2 << 0x0c) | (byte3 << 0x06) | byte4;\n      if (unit > 0xffff) {\n        unit -= 0x10000;\n        units.push(((unit >>> 10) & 0x3ff) | 0xd800);\n        unit = 0xdc00 | (unit & 0x3ff);\n      }\n      units.push(unit);\n    } else {\n      units.push(byte1);\n    }\n\n    if (units.length >= CHUNK_SIZE) {\n      result += String.fromCharCode(...units);\n      units.length = 0;\n    }\n  }\n\n  if (units.length > 0) {\n    result += String.fromCharCode(...units);\n  }\n\n  return result;\n}\n\nconst sharedTextDecoder = new TextDecoder();\n\n// This threshold should be determined by benchmarking, which might vary in engines and input data.\n// Run `npx ts-node benchmark/decode-string.ts` for details.\nconst TEXT_DECODER_THRESHOLD = 200;\n\nexport function utf8DecodeTD(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  const stringBytes = bytes.subarray(inputOffset, inputOffset + byteLength);\n  return sharedTextDecoder.decode(stringBytes);\n}\n\nexport function utf8Decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n  if (byteLength > TEXT_DECODER_THRESHOLD) {\n    return utf8DecodeTD(bytes, inputOffset, byteLength);\n  } else {\n    return utf8DecodeJs(bytes, inputOffset, byteLength);\n  }\n}\n", "/**\n * ExtData is used to handle Extension Types that are not registered to ExtensionCodec.\n */\nexport class ExtData {\n  readonly type: number;\n  readonly data: Uint8Array | ((pos: number) => Uint8Array);\n\n  constructor(type: number, data: Uint8Array | ((pos: number) => Uint8Array)) {\n    this.type = type;\n    this.data = data;\n  }\n}\n", "export class DecodeError extends Error {\n  constructor(message: string) {\n    super(message);\n\n    // fix the prototype chain in a cross-platform way\n    const proto: typeof DecodeError.prototype = Object.create(DecodeError.prototype);\n    Object.setPrototypeOf(this, proto);\n\n    Object.defineProperty(this, \"name\", {\n      configurable: true,\n      enumerable: false,\n      value: DecodeError.name,\n    });\n  }\n}\n", "// Integer Utility\n\nexport const UINT32_MAX = 0xffff_ffff;\n\n// DataView extension to handle int64 / uint64,\n// where the actual range is 53-bits integer (a.k.a. safe integer)\n\nexport function setUint64(view: DataView, offset: number, value: number): void {\n  const high = value / 0x1_0000_0000;\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function setInt64(view: DataView, offset: number, value: number): void {\n  const high = Math.floor(value / 0x1_0000_0000);\n  const low = value; // high bits are truncated by DataView\n  view.setUint32(offset, high);\n  view.setUint32(offset + 4, low);\n}\n\nexport function getInt64(view: DataView, offset: number): number {\n  const high = view.getInt32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n\nexport function getUint64(view: DataView, offset: number): number {\n  const high = view.getUint32(offset);\n  const low = view.getUint32(offset + 4);\n  return high * 0x1_0000_0000 + low;\n}\n", "// https://github.com/msgpack/msgpack/blob/master/spec.md#timestamp-extension-type\nimport { DecodeError } from \"./DecodeError.ts\";\nimport { getInt64, setInt64 } from \"./utils/int.ts\";\n\nexport const EXT_TIMESTAMP = -1;\n\nexport type TimeSpec = {\n  sec: number;\n  nsec: number;\n};\n\nconst TIMESTAMP32_MAX_SEC = 0x100000000 - 1; // 32-bit unsigned int\nconst TIMESTAMP64_MAX_SEC = 0x400000000 - 1; // 34-bit unsigned int\n\nexport function encodeTimeSpecToTimestamp({ sec, nsec }: TimeSpec): Uint8Array {\n  if (sec >= 0 && nsec >= 0 && sec <= TIMESTAMP64_MAX_SEC) {\n    // Here sec >= 0 && nsec >= 0\n    if (nsec === 0 && sec <= TIMESTAMP32_MAX_SEC) {\n      // timestamp 32 = { sec32 (unsigned) }\n      const rv = new Uint8Array(4);\n      const view = new DataView(rv.buffer);\n      view.setUint32(0, sec);\n      return rv;\n    } else {\n      // timestamp 64 = { nsec30 (unsigned), sec34 (unsigned) }\n      const secHigh = sec / 0x100000000;\n      const secLow = sec & 0xffffffff;\n      const rv = new Uint8Array(8);\n      const view = new DataView(rv.buffer);\n      // nsec30 | secHigh2\n      view.setUint32(0, (nsec << 2) | (secHigh & 0x3));\n      // secLow32\n      view.setUint32(4, secLow);\n      return rv;\n    }\n  } else {\n    // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n    const rv = new Uint8Array(12);\n    const view = new DataView(rv.buffer);\n    view.setUint32(0, nsec);\n    setInt64(view, 4, sec);\n    return rv;\n  }\n}\n\nexport function encodeDateToTimeSpec(date: Date): TimeSpec {\n  const msec = date.getTime();\n  const sec = Math.floor(msec / 1e3);\n  const nsec = (msec - sec * 1e3) * 1e6;\n\n  // Normalizes { sec, nsec } to ensure nsec is unsigned.\n  const nsecInSec = Math.floor(nsec / 1e9);\n  return {\n    sec: sec + nsecInSec,\n    nsec: nsec - nsecInSec * 1e9,\n  };\n}\n\nexport function encodeTimestampExtension(object: unknown): Uint8Array | null {\n  if (object instanceof Date) {\n    const timeSpec = encodeDateToTimeSpec(object);\n    return encodeTimeSpecToTimestamp(timeSpec);\n  } else {\n    return null;\n  }\n}\n\nexport function decodeTimestampToTimeSpec(data: Uint8Array): TimeSpec {\n  const view = new DataView(data.buffer, data.byteOffset, data.byteLength);\n\n  // data may be 32, 64, or 96 bits\n  switch (data.byteLength) {\n    case 4: {\n      // timestamp 32 = { sec32 }\n      const sec = view.getUint32(0);\n      const nsec = 0;\n      return { sec, nsec };\n    }\n    case 8: {\n      // timestamp 64 = { nsec30, sec34 }\n      const nsec30AndSecHigh2 = view.getUint32(0);\n      const secLow32 = view.getUint32(4);\n      const sec = (nsec30AndSecHigh2 & 0x3) * 0x100000000 + secLow32;\n      const nsec = nsec30AndSecHigh2 >>> 2;\n      return { sec, nsec };\n    }\n    case 12: {\n      // timestamp 96 = { nsec32 (unsigned), sec64 (signed) }\n\n      const sec = getInt64(view, 4);\n      const nsec = view.getUint32(0);\n      return { sec, nsec };\n    }\n    default:\n      throw new DecodeError(`Unrecognized data size for timestamp (expected 4, 8, or 12): ${data.length}`);\n  }\n}\n\nexport function decodeTimestampExtension(data: Uint8Array): Date {\n  const timeSpec = decodeTimestampToTimeSpec(data);\n  return new Date(timeSpec.sec * 1e3 + timeSpec.nsec / 1e6);\n}\n\nexport const timestampExtension = {\n  type: EXT_TIMESTAMP,\n  encode: encodeTimestampExtension,\n  decode: decodeTimestampExtension,\n};\n", "// ExtensionCodec to handle MessagePack extensions\n\nimport { ExtData } from \"./ExtData.ts\";\nimport { timestampExtension } from \"./timestamp.ts\";\n\nexport type ExtensionDecoderType<ContextType> = (\n  data: Uint8Array,\n  extensionType: number,\n  context: ContextType,\n) => unknown;\n\nexport type ExtensionEncoderType<ContextType> = (\n  input: unknown,\n  context: ContextType,\n) => Uint8Array | ((dataPos: number) => Uint8Array) | null;\n\n// immutable interface to ExtensionCodec\nexport type ExtensionCodecType<ContextType> = {\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n  tryToEncode(object: unknown, context: ContextType): ExtData | null;\n  decode(data: Uint8Array, extType: number, context: ContextType): unknown;\n};\n\nexport class ExtensionCodec<ContextType = undefined> implements ExtensionCodecType<ContextType> {\n  public static readonly defaultCodec: ExtensionCodecType<undefined> = new ExtensionCodec();\n\n  // ensures ExtensionCodecType<X> matches ExtensionCodec<X>\n  // this will make type errors a lot more clear\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n  __brand?: ContextType;\n\n  // built-in extensions\n  private readonly builtInEncoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly builtInDecoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  // custom extensions\n  private readonly encoders: Array<ExtensionEncoderType<ContextType> | undefined | null> = [];\n  private readonly decoders: Array<ExtensionDecoderType<ContextType> | undefined | null> = [];\n\n  public constructor() {\n    this.register(timestampExtension);\n  }\n\n  public register({\n    type,\n    encode,\n    decode,\n  }: {\n    type: number;\n    encode: ExtensionEncoderType<ContextType>;\n    decode: ExtensionDecoderType<ContextType>;\n  }): void {\n    if (type >= 0) {\n      // custom extensions\n      this.encoders[type] = encode;\n      this.decoders[type] = decode;\n    } else {\n      // built-in extensions\n      const index = -1 - type;\n      this.builtInEncoders[index] = encode;\n      this.builtInDecoders[index] = decode;\n    }\n  }\n\n  public tryToEncode(object: unknown, context: ContextType): ExtData | null {\n    // built-in extensions\n    for (let i = 0; i < this.builtInEncoders.length; i++) {\n      const encodeExt = this.builtInEncoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = -1 - i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    // custom extensions\n    for (let i = 0; i < this.encoders.length; i++) {\n      const encodeExt = this.encoders[i];\n      if (encodeExt != null) {\n        const data = encodeExt(object, context);\n        if (data != null) {\n          const type = i;\n          return new ExtData(type, data);\n        }\n      }\n    }\n\n    if (object instanceof ExtData) {\n      // to keep ExtData as is\n      return object;\n    }\n    return null;\n  }\n\n  public decode(data: Uint8Array, type: number, context: ContextType): unknown {\n    const decodeExt = type < 0 ? this.builtInDecoders[-1 - type] : this.decoders[type];\n    if (decodeExt) {\n      return decodeExt(data, type, context);\n    } else {\n      // decode() does not fail, returns ExtData instead.\n      return new ExtData(type, data);\n    }\n  }\n}\n", "function isArrayBufferLike(buffer: unknown): buffer is ArrayBufferLike {\n  return (\n    buffer instanceof ArrayBuffer || (typeof SharedArrayBuffer !== \"undefined\" && buffer instanceof SharedArrayBuffer)\n  );\n}\n\nexport function ensureUint8Array(\n  buffer: ArrayLike<number> | Uint8Array<ArrayBufferLike> | ArrayBufferView | ArrayBufferLike,\n): Uint8Array<ArrayBufferLike> {\n  if (buffer instanceof Uint8Array) {\n    return buffer;\n  } else if (ArrayBuffer.isView(buffer)) {\n    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);\n  } else if (isArrayBufferLike(buffer)) {\n    return new Uint8Array(buffer);\n  } else {\n    // ArrayLike<number>\n    return Uint8Array.from(buffer);\n  }\n}\n", "import { utf8Count, utf8Encode } from \"./utils/utf8.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { setInt64, setUint64 } from \"./utils/int.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport type { ExtData } from \"./ExtData.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\n\nexport const DEFAULT_MAX_DEPTH = 100;\nexport const DEFAULT_INITIAL_BUFFER_SIZE = 2048;\n\nexport type EncoderOptions<ContextType = undefined> = Partial<\n  Readonly<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Encodes bigint as Int64 or Uint64 if it's set to true.\n     * {@link forceIntegerToFloat} does not affect bigint.\n     * Depends on ES2020's {@link DataView#setBigInt64} and\n     * {@link DataView#setBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * The maximum depth in nested objects and arrays.\n     *\n     * Defaults to 100.\n     */\n    maxDepth: number;\n\n    /**\n     * The initial size of the internal buffer.\n     *\n     * Defaults to 2048.\n     */\n    initialBufferSize: number;\n\n    /**\n     * If `true`, the keys of an object is sorted. In other words, the encoded\n     * binary is canonical and thus comparable to another encoded binary.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    sortKeys: boolean;\n    /**\n     * If `true`, non-integer numbers are encoded in float32, not in float64 (the default).\n     *\n     * Only use it if precisions don't matter.\n     *\n     * Defaults to `false`.\n     */\n    forceFloat32: boolean;\n\n    /**\n     * If `true`, an object property with `undefined` value are ignored.\n     * e.g. `{ foo: undefined }` will be encoded as `{}`, as `JSON.stringify()` does.\n     *\n     * Defaults to `false`. If enabled, it spends more time in encoding objects.\n     */\n    ignoreUndefined: boolean;\n\n    /**\n     * If `true`, integer numbers are encoded as floating point numbers,\n     * with the `forceFloat32` option taken into account.\n     *\n     * Defaults to `false`.\n     */\n    forceIntegerToFloat: boolean;\n  }>\n> &\n  ContextOf<ContextType>;\n\nexport class Encoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly maxDepth: number;\n  private readonly initialBufferSize: number;\n  private readonly sortKeys: boolean;\n  private readonly forceFloat32: boolean;\n  private readonly ignoreUndefined: boolean;\n  private readonly forceIntegerToFloat: boolean;\n\n  private pos: number;\n  private view: DataView<ArrayBuffer>;\n  private bytes: Uint8Array<ArrayBuffer>;\n\n  private entered = false;\n\n  public constructor(options?: EncoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.maxDepth = options?.maxDepth ?? DEFAULT_MAX_DEPTH;\n    this.initialBufferSize = options?.initialBufferSize ?? DEFAULT_INITIAL_BUFFER_SIZE;\n    this.sortKeys = options?.sortKeys ?? false;\n    this.forceFloat32 = options?.forceFloat32 ?? false;\n    this.ignoreUndefined = options?.ignoreUndefined ?? false;\n    this.forceIntegerToFloat = options?.forceIntegerToFloat ?? false;\n\n    this.pos = 0;\n    this.view = new DataView(new ArrayBuffer(this.initialBufferSize));\n    this.bytes = new Uint8Array(this.view.buffer);\n  }\n\n  private clone() {\n    // Because of slightly special argument `context`,\n    // type assertion is needed.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Encoder<ContextType>({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      maxDepth: this.maxDepth,\n      initialBufferSize: this.initialBufferSize,\n      sortKeys: this.sortKeys,\n      forceFloat32: this.forceFloat32,\n      ignoreUndefined: this.ignoreUndefined,\n      forceIntegerToFloat: this.forceIntegerToFloat,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.pos = 0;\n  }\n\n  /**\n   * This is almost equivalent to {@link Encoder#encode}, but it returns an reference of the encoder's internal buffer and thus much faster than {@link Encoder#encode}.\n   *\n   * @returns Encodes the object and returns a shared reference the encoder's internal buffer.\n   */\n  public encodeSharedRef(object: unknown): Uint8Array<ArrayBuffer> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encodeSharedRef(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.subarray(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  /**\n   * @returns Encodes the object and returns a copy of the encoder's internal buffer.\n   */\n  public encode(object: unknown): Uint8Array<ArrayBuffer> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.encode(object);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.doEncode(object, 1);\n      return this.bytes.slice(0, this.pos);\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doEncode(object: unknown, depth: number): void {\n    if (depth > this.maxDepth) {\n      throw new Error(`Too deep objects in depth ${depth}`);\n    }\n\n    if (object == null) {\n      this.encodeNil();\n    } else if (typeof object === \"boolean\") {\n      this.encodeBoolean(object);\n    } else if (typeof object === \"number\") {\n      if (!this.forceIntegerToFloat) {\n        this.encodeNumber(object);\n      } else {\n        this.encodeNumberAsFloat(object);\n      }\n    } else if (typeof object === \"string\") {\n      this.encodeString(object);\n    } else if (this.useBigInt64 && typeof object === \"bigint\") {\n      this.encodeBigInt64(object);\n    } else {\n      this.encodeObject(object, depth);\n    }\n  }\n\n  private ensureBufferSizeToWrite(sizeToWrite: number) {\n    const requiredSize = this.pos + sizeToWrite;\n\n    if (this.view.byteLength < requiredSize) {\n      this.resizeBuffer(requiredSize * 2);\n    }\n  }\n\n  private resizeBuffer(newSize: number) {\n    const newBuffer = new ArrayBuffer(newSize);\n    const newBytes = new Uint8Array(newBuffer);\n    const newView = new DataView(newBuffer);\n\n    newBytes.set(this.bytes);\n\n    this.view = newView;\n    this.bytes = newBytes;\n  }\n\n  private encodeNil() {\n    this.writeU8(0xc0);\n  }\n\n  private encodeBoolean(object: boolean) {\n    if (object === false) {\n      this.writeU8(0xc2);\n    } else {\n      this.writeU8(0xc3);\n    }\n  }\n\n  private encodeNumber(object: number): void {\n    if (!this.forceIntegerToFloat && Number.isSafeInteger(object)) {\n      if (object >= 0) {\n        if (object < 0x80) {\n          // positive fixint\n          this.writeU8(object);\n        } else if (object < 0x100) {\n          // uint 8\n          this.writeU8(0xcc);\n          this.writeU8(object);\n        } else if (object < 0x10000) {\n          // uint 16\n          this.writeU8(0xcd);\n          this.writeU16(object);\n        } else if (object < 0x100000000) {\n          // uint 32\n          this.writeU8(0xce);\n          this.writeU32(object);\n        } else if (!this.useBigInt64) {\n          // uint 64\n          this.writeU8(0xcf);\n          this.writeU64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      } else {\n        if (object >= -0x20) {\n          // negative fixint\n          this.writeU8(0xe0 | (object + 0x20));\n        } else if (object >= -0x80) {\n          // int 8\n          this.writeU8(0xd0);\n          this.writeI8(object);\n        } else if (object >= -0x8000) {\n          // int 16\n          this.writeU8(0xd1);\n          this.writeI16(object);\n        } else if (object >= -0x80000000) {\n          // int 32\n          this.writeU8(0xd2);\n          this.writeI32(object);\n        } else if (!this.useBigInt64) {\n          // int 64\n          this.writeU8(0xd3);\n          this.writeI64(object);\n        } else {\n          this.encodeNumberAsFloat(object);\n        }\n      }\n    } else {\n      this.encodeNumberAsFloat(object);\n    }\n  }\n\n  private encodeNumberAsFloat(object: number): void {\n    if (this.forceFloat32) {\n      // float 32\n      this.writeU8(0xca);\n      this.writeF32(object);\n    } else {\n      // float 64\n      this.writeU8(0xcb);\n      this.writeF64(object);\n    }\n  }\n\n  private encodeBigInt64(object: bigint): void {\n    if (object >= BigInt(0)) {\n      // uint 64\n      this.writeU8(0xcf);\n      this.writeBigUint64(object);\n    } else {\n      // int 64\n      this.writeU8(0xd3);\n      this.writeBigInt64(object);\n    }\n  }\n\n  private writeStringHeader(byteLength: number) {\n    if (byteLength < 32) {\n      // fixstr\n      this.writeU8(0xa0 + byteLength);\n    } else if (byteLength < 0x100) {\n      // str 8\n      this.writeU8(0xd9);\n      this.writeU8(byteLength);\n    } else if (byteLength < 0x10000) {\n      // str 16\n      this.writeU8(0xda);\n      this.writeU16(byteLength);\n    } else if (byteLength < 0x100000000) {\n      // str 32\n      this.writeU8(0xdb);\n      this.writeU32(byteLength);\n    } else {\n      throw new Error(`Too long string: ${byteLength} bytes in UTF-8`);\n    }\n  }\n\n  private encodeString(object: string) {\n    const maxHeaderSize = 1 + 4;\n\n    const byteLength = utf8Count(object);\n    this.ensureBufferSizeToWrite(maxHeaderSize + byteLength);\n    this.writeStringHeader(byteLength);\n    utf8Encode(object, this.bytes, this.pos);\n    this.pos += byteLength;\n  }\n\n  private encodeObject(object: unknown, depth: number) {\n    // try to encode objects with custom codec first of non-primitives\n    const ext = this.extensionCodec.tryToEncode(object, this.context);\n    if (ext != null) {\n      this.encodeExtension(ext);\n    } else if (Array.isArray(object)) {\n      this.encodeArray(object, depth);\n    } else if (ArrayBuffer.isView(object)) {\n      this.encodeBinary(object);\n    } else if (typeof object === \"object\") {\n      this.encodeMap(object as Record<string, unknown>, depth);\n    } else {\n      // symbol, function and other special object come here unless extensionCodec handles them.\n      throw new Error(`Unrecognized object: ${Object.prototype.toString.apply(object)}`);\n    }\n  }\n\n  private encodeBinary(object: ArrayBufferView) {\n    const size = object.byteLength;\n    if (size < 0x100) {\n      // bin 8\n      this.writeU8(0xc4);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // bin 16\n      this.writeU8(0xc5);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // bin 32\n      this.writeU8(0xc6);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large binary: ${size}`);\n    }\n    const bytes = ensureUint8Array(object);\n    this.writeU8a(bytes);\n  }\n\n  private encodeArray(object: Array<unknown>, depth: number) {\n    const size = object.length;\n    if (size < 16) {\n      // fixarray\n      this.writeU8(0x90 + size);\n    } else if (size < 0x10000) {\n      // array 16\n      this.writeU8(0xdc);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // array 32\n      this.writeU8(0xdd);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large array: ${size}`);\n    }\n    for (const item of object) {\n      this.doEncode(item, depth + 1);\n    }\n  }\n\n  private countWithoutUndefined(object: Record<string, unknown>, keys: ReadonlyArray<string>): number {\n    let count = 0;\n\n    for (const key of keys) {\n      if (object[key] !== undefined) {\n        count++;\n      }\n    }\n\n    return count;\n  }\n\n  private encodeMap(object: Record<string, unknown>, depth: number) {\n    const keys = Object.keys(object);\n    if (this.sortKeys) {\n      keys.sort();\n    }\n\n    const size = this.ignoreUndefined ? this.countWithoutUndefined(object, keys) : keys.length;\n\n    if (size < 16) {\n      // fixmap\n      this.writeU8(0x80 + size);\n    } else if (size < 0x10000) {\n      // map 16\n      this.writeU8(0xde);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // map 32\n      this.writeU8(0xdf);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large map object: ${size}`);\n    }\n\n    for (const key of keys) {\n      const value = object[key];\n\n      if (!(this.ignoreUndefined && value === undefined)) {\n        this.encodeString(key);\n        this.doEncode(value, depth + 1);\n      }\n    }\n  }\n\n  private encodeExtension(ext: ExtData) {\n    if (typeof ext.data === \"function\") {\n      const data = ext.data(this.pos + 6);\n      const size = data.length;\n\n      if (size >= 0x100000000) {\n        throw new Error(`Too large extension object: ${size}`);\n      }\n\n      this.writeU8(0xc9);\n      this.writeU32(size);\n      this.writeI8(ext.type);\n      this.writeU8a(data);\n      return;\n    }\n\n    const size = ext.data.length;\n    if (size === 1) {\n      // fixext 1\n      this.writeU8(0xd4);\n    } else if (size === 2) {\n      // fixext 2\n      this.writeU8(0xd5);\n    } else if (size === 4) {\n      // fixext 4\n      this.writeU8(0xd6);\n    } else if (size === 8) {\n      // fixext 8\n      this.writeU8(0xd7);\n    } else if (size === 16) {\n      // fixext 16\n      this.writeU8(0xd8);\n    } else if (size < 0x100) {\n      // ext 8\n      this.writeU8(0xc7);\n      this.writeU8(size);\n    } else if (size < 0x10000) {\n      // ext 16\n      this.writeU8(0xc8);\n      this.writeU16(size);\n    } else if (size < 0x100000000) {\n      // ext 32\n      this.writeU8(0xc9);\n      this.writeU32(size);\n    } else {\n      throw new Error(`Too large extension object: ${size}`);\n    }\n    this.writeI8(ext.type);\n    this.writeU8a(ext.data);\n  }\n\n  private writeU8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setUint8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU8a(values: ArrayLike<number>) {\n    const size = values.length;\n    this.ensureBufferSizeToWrite(size);\n\n    this.bytes.set(values, this.pos);\n    this.pos += size;\n  }\n\n  private writeI8(value: number) {\n    this.ensureBufferSizeToWrite(1);\n\n    this.view.setInt8(this.pos, value);\n    this.pos++;\n  }\n\n  private writeU16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setUint16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeI16(value: number) {\n    this.ensureBufferSizeToWrite(2);\n\n    this.view.setInt16(this.pos, value);\n    this.pos += 2;\n  }\n\n  private writeU32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setUint32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeI32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setInt32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF32(value: number) {\n    this.ensureBufferSizeToWrite(4);\n\n    this.view.setFloat32(this.pos, value);\n    this.pos += 4;\n  }\n\n  private writeF64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setFloat64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeU64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setUint64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeI64(value: number) {\n    this.ensureBufferSizeToWrite(8);\n\n    setInt64(this.view, this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigUint64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigUint64(this.pos, value);\n    this.pos += 8;\n  }\n\n  private writeBigInt64(value: bigint) {\n    this.ensureBufferSizeToWrite(8);\n\n    this.view.setBigInt64(this.pos, value);\n    this.pos += 8;\n  }\n}\n", "import { Encoder } from \"./Encoder.ts\";\nimport type { EncoderOptions } from \"./Encoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It encodes `value` in the MessagePack format and\n * returns a byte buffer.\n *\n * The returned buffer is a slice of a larger `ArrayBuffer`, so you have to use its `#byteOffset` and `#byteLength` in order to convert it to another typed arrays including NodeJS `Buffer`.\n */\nexport function encode<ContextType = undefined>(\n  value: unknown,\n  options?: EncoderOptions<SplitUndefined<ContextType>>,\n): Uint8Array<ArrayBuffer> {\n  const encoder = new Encoder(options);\n  return encoder.encodeSharedRef(value);\n}\n", "export function prettyByte(byte: number): string {\n  return `${byte < 0 ? \"-\" : \"\"}0x${Math.abs(byte).toString(16).padStart(2, \"0\")}`;\n}\n", "import { utf8DecodeJs } from \"./utils/utf8.ts\";\n\nconst DEFAULT_MAX_KEY_LENGTH = 16;\nconst DEFAULT_MAX_LENGTH_PER_KEY = 16;\n\nexport interface KeyDecoder {\n  canBeCached(byteLength: number): boolean;\n  decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string;\n}\ninterface KeyCacheRecord {\n  readonly bytes: Uint8Array;\n  readonly str: string;\n}\n\nexport class CachedKeyDecoder implements KeyDecoder {\n  hit = 0;\n  miss = 0;\n  private readonly caches: Array<Array<KeyCacheRecord>>;\n  readonly maxKeyLength: number;\n  readonly maxLengthPerKey: number;\n\n  constructor(maxKeyLength = DEFAULT_MAX_KEY_LENGTH, maxLengthPerKey = DEFAULT_MAX_LENGTH_PER_KEY) {\n    this.maxKeyLength = maxKeyLength;\n    this.maxLengthPerKey = maxLengthPerKey;\n\n    // avoid `new Array(N)`, which makes a sparse array,\n    // because a sparse array is typically slower than a non-sparse array.\n    this.caches = [];\n    for (let i = 0; i < this.maxKeyLength; i++) {\n      this.caches.push([]);\n    }\n  }\n\n  public canBeCached(byteLength: number): boolean {\n    return byteLength > 0 && byteLength <= this.maxKeyLength;\n  }\n\n  private find(bytes: Uint8Array, inputOffset: number, byteLength: number): string | null {\n    const records = this.caches[byteLength - 1]!;\n\n    FIND_CHUNK: for (const record of records) {\n      const recordBytes = record.bytes;\n\n      for (let j = 0; j < byteLength; j++) {\n        if (recordBytes[j] !== bytes[inputOffset + j]) {\n          continue FIND_CHUNK;\n        }\n      }\n      return record.str;\n    }\n    return null;\n  }\n\n  private store(bytes: Uint8Array, value: string) {\n    const records = this.caches[bytes.length - 1]!;\n    const record: KeyCacheRecord = { bytes, str: value };\n\n    if (records.length >= this.maxLengthPerKey) {\n      // `records` are full!\n      // Set `record` to an arbitrary position.\n      records[(Math.random() * records.length) | 0] = record;\n    } else {\n      records.push(record);\n    }\n  }\n\n  public decode(bytes: Uint8Array, inputOffset: number, byteLength: number): string {\n    const cachedValue = this.find(bytes, inputOffset, byteLength);\n    if (cachedValue != null) {\n      this.hit++;\n      return cachedValue;\n    }\n    this.miss++;\n\n    const str = utf8DecodeJs(bytes, inputOffset, byteLength);\n    // Ensure to copy a slice of bytes because the bytes may be a NodeJS Buffer and Buffer#slice() returns a reference to its internal ArrayBuffer.\n    const slicedCopyOfBytes = Uint8Array.prototype.slice.call(bytes, inputOffset, inputOffset + byteLength);\n    this.store(slicedCopyOfBytes, str);\n    return str;\n  }\n}\n", "import { prettyByte } from \"./utils/prettyByte.ts\";\nimport { ExtensionCodec } from \"./ExtensionCodec.ts\";\nimport { getInt64, getUint64, UINT32_MAX } from \"./utils/int.ts\";\nimport { utf8Decode } from \"./utils/utf8.ts\";\nimport { ensureUint8Array } from \"./utils/typedArrays.ts\";\nimport { CachedKeyDecoder } from \"./CachedKeyDecoder.ts\";\nimport { DecodeError } from \"./DecodeError.ts\";\nimport type { ContextOf } from \"./context.ts\";\nimport type { ExtensionCodecType } from \"./ExtensionCodec.ts\";\nimport type { KeyDecoder } from \"./CachedKeyDecoder.ts\";\n\nexport type DecoderOptions<ContextType = undefined> = Readonly<\n  Partial<{\n    extensionCodec: ExtensionCodecType<ContextType>;\n\n    /**\n     * Decodes Int64 and Uint64 as bigint if it's set to true.\n     * Depends on ES2020's {@link DataView#getBigInt64} and\n     * {@link DataView#getBigUint64}.\n     *\n     * Defaults to false.\n     */\n    useBigInt64: boolean;\n\n    /**\n     * By default, string values will be decoded as UTF-8 strings. However, if this option is true,\n     * string values will be returned as Uint8Arrays without additional decoding.\n     *\n     * This is useful if the strings may contain invalid UTF-8 sequences.\n     *\n     * Note that this option only applies to string values, not map keys. Additionally, when\n     * enabled, raw string length is limited by the maxBinLength option.\n     */\n    rawStrings: boolean;\n\n    /**\n     * Maximum string length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxStrLength: number;\n    /**\n     * Maximum binary length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxBinLength: number;\n    /**\n     * Maximum array length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxArrayLength: number;\n    /**\n     * Maximum map length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxMapLength: number;\n    /**\n     * Maximum extension length.\n     *\n     * Defaults to 4_294_967_295 (UINT32_MAX).\n     */\n    maxExtLength: number;\n\n    /**\n     * An object key decoder. Defaults to the shared instance of {@link CachedKeyDecoder}.\n     * `null` is a special value to disable the use of the key decoder at all.\n     */\n    keyDecoder: KeyDecoder | null;\n\n    /**\n     * A function to convert decoded map key to a valid JS key type.\n     *\n     * Defaults to a function that throws an error if the key is not a string or a number.\n     */\n    mapKeyConverter: (key: unknown) => MapKeyType;\n  }>\n> &\n  ContextOf<ContextType>;\n\nconst STATE_ARRAY = \"array\";\nconst STATE_MAP_KEY = \"map_key\";\nconst STATE_MAP_VALUE = \"map_value\";\n\ntype MapKeyType = string | number;\n\nconst mapKeyConverter = (key: unknown): MapKeyType => {\n  if (typeof key === \"string\" || typeof key === \"number\") {\n    return key;\n  }\n  throw new DecodeError(\"The type of key must be string or number but \" + typeof key);\n};\n\ntype StackMapState = {\n  type: typeof STATE_MAP_KEY | typeof STATE_MAP_VALUE;\n  size: number;\n  key: MapKeyType | null;\n  readCount: number;\n  map: Record<string, unknown>;\n};\n\ntype StackArrayState = {\n  type: typeof STATE_ARRAY;\n  size: number;\n  array: Array<unknown>;\n  position: number;\n};\n\nclass StackPool {\n  private readonly stack: Array<StackState> = [];\n  private stackHeadPosition = -1;\n\n  public get length(): number {\n    return this.stackHeadPosition + 1;\n  }\n\n  public top(): StackState | undefined {\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public pushArrayState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackArrayState;\n\n    state.type = STATE_ARRAY;\n    state.position = 0;\n    state.size = size;\n    state.array = new Array(size);\n  }\n\n  public pushMapState(size: number) {\n    const state = this.getUninitializedStateFromPool() as StackMapState;\n\n    state.type = STATE_MAP_KEY;\n    state.readCount = 0;\n    state.size = size;\n    state.map = {};\n  }\n\n  private getUninitializedStateFromPool() {\n    this.stackHeadPosition++;\n\n    if (this.stackHeadPosition === this.stack.length) {\n      const partialState: Partial<StackState> = {\n        type: undefined,\n        size: 0,\n        array: undefined,\n        position: 0,\n        readCount: 0,\n        map: undefined,\n        key: null,\n      };\n\n      this.stack.push(partialState as StackState);\n    }\n\n    return this.stack[this.stackHeadPosition];\n  }\n\n  public release(state: StackState): void {\n    const topStackState = this.stack[this.stackHeadPosition];\n\n    if (topStackState !== state) {\n      throw new Error(\"Invalid stack state. Released state is not on top of the stack.\");\n    }\n\n    if (state.type === STATE_ARRAY) {\n      const partialState = state as Partial<StackArrayState>;\n      partialState.size = 0;\n      partialState.array = undefined;\n      partialState.position = 0;\n      partialState.type = undefined;\n    }\n\n    if (state.type === STATE_MAP_KEY || state.type === STATE_MAP_VALUE) {\n      const partialState = state as Partial<StackMapState>;\n      partialState.size = 0;\n      partialState.map = undefined;\n      partialState.readCount = 0;\n      partialState.type = undefined;\n    }\n\n    this.stackHeadPosition--;\n  }\n\n  public reset(): void {\n    this.stack.length = 0;\n    this.stackHeadPosition = -1;\n  }\n}\n\ntype StackState = StackArrayState | StackMapState;\n\nconst HEAD_BYTE_REQUIRED = -1;\n\nconst EMPTY_VIEW = new DataView<ArrayBufferLike>(new ArrayBuffer(0));\nconst EMPTY_BYTES = new Uint8Array<ArrayBufferLike>(EMPTY_VIEW.buffer);\n\ntry {\n  // IE11: The spec says it should throw RangeError,\n  // IE11: but in IE11 it throws TypeError.\n  EMPTY_VIEW.getInt8(0);\n} catch (e) {\n  if (!(e instanceof RangeError)) {\n    throw new Error(\n      \"This module is not supported in the current JavaScript engine because DataView does not throw RangeError on out-of-bounds access\",\n    );\n  }\n}\n\nconst MORE_DATA = new RangeError(\"Insufficient data\");\n\nconst sharedCachedKeyDecoder = new CachedKeyDecoder();\n\nexport class Decoder<ContextType = undefined> {\n  private readonly extensionCodec: ExtensionCodecType<ContextType>;\n  private readonly context: ContextType;\n  private readonly useBigInt64: boolean;\n  private readonly rawStrings: boolean;\n  private readonly maxStrLength: number;\n  private readonly maxBinLength: number;\n  private readonly maxArrayLength: number;\n  private readonly maxMapLength: number;\n  private readonly maxExtLength: number;\n  private readonly keyDecoder: KeyDecoder | null;\n  private readonly mapKeyConverter: (key: unknown) => MapKeyType;\n\n  private totalPos = 0;\n  private pos = 0;\n\n  private view = EMPTY_VIEW;\n  private bytes = EMPTY_BYTES;\n  private headByte = HEAD_BYTE_REQUIRED;\n  private readonly stack = new StackPool();\n\n  private entered = false;\n\n  public constructor(options?: DecoderOptions<ContextType>) {\n    this.extensionCodec = options?.extensionCodec ?? (ExtensionCodec.defaultCodec as ExtensionCodecType<ContextType>);\n    this.context = (options as { context: ContextType } | undefined)?.context as ContextType; // needs a type assertion because EncoderOptions has no context property when ContextType is undefined\n\n    this.useBigInt64 = options?.useBigInt64 ?? false;\n    this.rawStrings = options?.rawStrings ?? false;\n    this.maxStrLength = options?.maxStrLength ?? UINT32_MAX;\n    this.maxBinLength = options?.maxBinLength ?? UINT32_MAX;\n    this.maxArrayLength = options?.maxArrayLength ?? UINT32_MAX;\n    this.maxMapLength = options?.maxMapLength ?? UINT32_MAX;\n    this.maxExtLength = options?.maxExtLength ?? UINT32_MAX;\n    this.keyDecoder = options?.keyDecoder !== undefined ? options.keyDecoder : sharedCachedKeyDecoder;\n    this.mapKeyConverter = options?.mapKeyConverter ?? mapKeyConverter;\n  }\n\n  private clone(): Decoder<ContextType> {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n    return new Decoder({\n      extensionCodec: this.extensionCodec,\n      context: this.context,\n      useBigInt64: this.useBigInt64,\n      rawStrings: this.rawStrings,\n      maxStrLength: this.maxStrLength,\n      maxBinLength: this.maxBinLength,\n      maxArrayLength: this.maxArrayLength,\n      maxMapLength: this.maxMapLength,\n      maxExtLength: this.maxExtLength,\n      keyDecoder: this.keyDecoder,\n    } as any);\n  }\n\n  private reinitializeState() {\n    this.totalPos = 0;\n    this.headByte = HEAD_BYTE_REQUIRED;\n    this.stack.reset();\n\n    // view, bytes, and pos will be re-initialized in setBuffer()\n  }\n\n  private setBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    const bytes = ensureUint8Array(buffer);\n    this.bytes = bytes;\n    this.view = new DataView(bytes.buffer, bytes.byteOffset, bytes.byteLength);\n    this.pos = 0;\n  }\n\n  private appendBuffer(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): void {\n    if (this.headByte === HEAD_BYTE_REQUIRED && !this.hasRemaining(1)) {\n      this.setBuffer(buffer);\n    } else {\n      const remainingData = this.bytes.subarray(this.pos);\n      const newData = ensureUint8Array(buffer);\n\n      // concat remainingData + newData\n      const newBuffer = new Uint8Array(remainingData.length + newData.length);\n      newBuffer.set(remainingData);\n      newBuffer.set(newData, remainingData.length);\n      this.setBuffer(newBuffer);\n    }\n  }\n\n  private hasRemaining(size: number) {\n    return this.view.byteLength - this.pos >= size;\n  }\n\n  private createExtraByteError(posToShow: number): Error {\n    const { view, pos } = this;\n    return new RangeError(`Extra ${view.byteLength - pos} of ${view.byteLength} byte(s) found at buffer[${posToShow}]`);\n  }\n\n  /**\n   * @throws {@link DecodeError}\n   * @throws {@link RangeError}\n   */\n  public decode(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): unknown {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decode(buffer);\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      const object = this.doDecodeSync();\n      if (this.hasRemaining(1)) {\n        throw this.createExtraByteError(this.pos);\n      }\n      return object;\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public *decodeMulti(buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike): Generator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMulti(buffer);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      this.reinitializeState();\n      this.setBuffer(buffer);\n\n      while (this.hasRemaining(1)) {\n        yield this.doDecodeSync();\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public async decodeAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): Promise<unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      return instance.decodeAsync(stream);\n    }\n\n    try {\n      this.entered = true;\n\n      let decoded = false;\n      let object: unknown;\n      for await (const buffer of stream) {\n        if (decoded) {\n          this.entered = false;\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        try {\n          object = this.doDecodeSync();\n          decoded = true;\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n\n      if (decoded) {\n        if (this.hasRemaining(1)) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n        return object;\n      }\n\n      const { headByte, pos, totalPos } = this;\n      throw new RangeError(\n        `Insufficient data in parsing ${prettyByte(headByte)} at ${totalPos} (${pos} in the current buffer)`,\n      );\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  public decodeArrayStream(\n    stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>,\n  ): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, true);\n  }\n\n  public decodeStream(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>): AsyncGenerator<unknown, void, unknown> {\n    return this.decodeMultiAsync(stream, false);\n  }\n\n  private async *decodeMultiAsync(stream: AsyncIterable<ArrayLike<number> | ArrayBufferView | ArrayBufferLike>, isArray: boolean): AsyncGenerator<unknown, void, unknown> {\n    if (this.entered) {\n      const instance = this.clone();\n      yield* instance.decodeMultiAsync(stream, isArray);\n      return;\n    }\n\n    try {\n      this.entered = true;\n\n      let isArrayHeaderRequired = isArray;\n      let arrayItemsLeft = -1;\n\n      for await (const buffer of stream) {\n        if (isArray && arrayItemsLeft === 0) {\n          throw this.createExtraByteError(this.totalPos);\n        }\n\n        this.appendBuffer(buffer);\n\n        if (isArrayHeaderRequired) {\n          arrayItemsLeft = this.readArraySize();\n          isArrayHeaderRequired = false;\n          this.complete();\n        }\n\n        try {\n          while (true) {\n            yield this.doDecodeSync();\n            if (--arrayItemsLeft === 0) {\n              break;\n            }\n          }\n        } catch (e) {\n          if (!(e instanceof RangeError)) {\n            throw e; // rethrow\n          }\n          // fallthrough\n        }\n        this.totalPos += this.pos;\n      }\n    } finally {\n      this.entered = false;\n    }\n  }\n\n  private doDecodeSync(): unknown {\n    DECODE: while (true) {\n      const headByte = this.readHeadByte();\n      let object: unknown;\n\n      if (headByte >= 0xe0) {\n        // negative fixint (111x xxxx) 0xe0 - 0xff\n        object = headByte - 0x100;\n      } else if (headByte < 0xc0) {\n        if (headByte < 0x80) {\n          // positive fixint (0xxx xxxx) 0x00 - 0x7f\n          object = headByte;\n        } else if (headByte < 0x90) {\n          // fixmap (1000 xxxx) 0x80 - 0x8f\n          const size = headByte - 0x80;\n          if (size !== 0) {\n            this.pushMapState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = {};\n          }\n        } else if (headByte < 0xa0) {\n          // fixarray (1001 xxxx) 0x90 - 0x9f\n          const size = headByte - 0x90;\n          if (size !== 0) {\n            this.pushArrayState(size);\n            this.complete();\n            continue DECODE;\n          } else {\n            object = [];\n          }\n        } else {\n          // fixstr (101x xxxx) 0xa0 - 0xbf\n          const byteLength = headByte - 0xa0;\n          object = this.decodeString(byteLength, 0);\n        }\n      } else if (headByte === 0xc0) {\n        // nil\n        object = null;\n      } else if (headByte === 0xc2) {\n        // false\n        object = false;\n      } else if (headByte === 0xc3) {\n        // true\n        object = true;\n      } else if (headByte === 0xca) {\n        // float 32\n        object = this.readF32();\n      } else if (headByte === 0xcb) {\n        // float 64\n        object = this.readF64();\n      } else if (headByte === 0xcc) {\n        // uint 8\n        object = this.readU8();\n      } else if (headByte === 0xcd) {\n        // uint 16\n        object = this.readU16();\n      } else if (headByte === 0xce) {\n        // uint 32\n        object = this.readU32();\n      } else if (headByte === 0xcf) {\n        // uint 64\n        if (this.useBigInt64) {\n          object = this.readU64AsBigInt();\n        } else {\n          object = this.readU64();\n        }\n      } else if (headByte === 0xd0) {\n        // int 8\n        object = this.readI8();\n      } else if (headByte === 0xd1) {\n        // int 16\n        object = this.readI16();\n      } else if (headByte === 0xd2) {\n        // int 32\n        object = this.readI32();\n      } else if (headByte === 0xd3) {\n        // int 64\n        if (this.useBigInt64) {\n          object = this.readI64AsBigInt();\n        } else {\n          object = this.readI64();\n        }\n      } else if (headByte === 0xd9) {\n        // str 8\n        const byteLength = this.lookU8();\n        object = this.decodeString(byteLength, 1);\n      } else if (headByte === 0xda) {\n        // str 16\n        const byteLength = this.lookU16();\n        object = this.decodeString(byteLength, 2);\n      } else if (headByte === 0xdb) {\n        // str 32\n        const byteLength = this.lookU32();\n        object = this.decodeString(byteLength, 4);\n      } else if (headByte === 0xdc) {\n        // array 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xdd) {\n        // array 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushArrayState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = [];\n        }\n      } else if (headByte === 0xde) {\n        // map 16\n        const size = this.readU16();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xdf) {\n        // map 32\n        const size = this.readU32();\n        if (size !== 0) {\n          this.pushMapState(size);\n          this.complete();\n          continue DECODE;\n        } else {\n          object = {};\n        }\n      } else if (headByte === 0xc4) {\n        // bin 8\n        const size = this.lookU8();\n        object = this.decodeBinary(size, 1);\n      } else if (headByte === 0xc5) {\n        // bin 16\n        const size = this.lookU16();\n        object = this.decodeBinary(size, 2);\n      } else if (headByte === 0xc6) {\n        // bin 32\n        const size = this.lookU32();\n        object = this.decodeBinary(size, 4);\n      } else if (headByte === 0xd4) {\n        // fixext 1\n        object = this.decodeExtension(1, 0);\n      } else if (headByte === 0xd5) {\n        // fixext 2\n        object = this.decodeExtension(2, 0);\n      } else if (headByte === 0xd6) {\n        // fixext 4\n        object = this.decodeExtension(4, 0);\n      } else if (headByte === 0xd7) {\n        // fixext 8\n        object = this.decodeExtension(8, 0);\n      } else if (headByte === 0xd8) {\n        // fixext 16\n        object = this.decodeExtension(16, 0);\n      } else if (headByte === 0xc7) {\n        // ext 8\n        const size = this.lookU8();\n        object = this.decodeExtension(size, 1);\n      } else if (headByte === 0xc8) {\n        // ext 16\n        const size = this.lookU16();\n        object = this.decodeExtension(size, 2);\n      } else if (headByte === 0xc9) {\n        // ext 32\n        const size = this.lookU32();\n        object = this.decodeExtension(size, 4);\n      } else {\n        throw new DecodeError(`Unrecognized type byte: ${prettyByte(headByte)}`);\n      }\n\n      this.complete();\n\n      const stack = this.stack;\n      while (stack.length > 0) {\n        // arrays and maps\n        const state = stack.top()!;\n        if (state.type === STATE_ARRAY) {\n          state.array[state.position] = object;\n          state.position++;\n          if (state.position === state.size) {\n            object = state.array;\n            stack.release(state);\n          } else {\n            continue DECODE;\n          }\n        } else if (state.type === STATE_MAP_KEY) {\n          if (object === \"__proto__\") {\n            throw new DecodeError(\"The key __proto__ is not allowed\");\n          }\n\n          state.key = this.mapKeyConverter(object);\n          state.type = STATE_MAP_VALUE;\n          continue DECODE;\n        } else {\n          // it must be `state.type === State.MAP_VALUE` here\n\n          state.map[state.key!] = object;\n          state.readCount++;\n\n          if (state.readCount === state.size) {\n            object = state.map;\n            stack.release(state);\n          } else {\n            state.key = null;\n            state.type = STATE_MAP_KEY;\n            continue DECODE;\n          }\n        }\n      }\n\n      return object;\n    }\n  }\n\n  private readHeadByte(): number {\n    if (this.headByte === HEAD_BYTE_REQUIRED) {\n      this.headByte = this.readU8();\n      // console.log(\"headByte\", prettyByte(this.headByte));\n    }\n\n    return this.headByte;\n  }\n\n  private complete(): void {\n    this.headByte = HEAD_BYTE_REQUIRED;\n  }\n\n  private readArraySize(): number {\n    const headByte = this.readHeadByte();\n\n    switch (headByte) {\n      case 0xdc:\n        return this.readU16();\n      case 0xdd:\n        return this.readU32();\n      default: {\n        if (headByte < 0xa0) {\n          return headByte - 0x90;\n        } else {\n          throw new DecodeError(`Unrecognized array type byte: ${prettyByte(headByte)}`);\n        }\n      }\n    }\n  }\n\n  private pushMapState(size: number) {\n    if (size > this.maxMapLength) {\n      throw new DecodeError(`Max length exceeded: map length (${size}) > maxMapLengthLength (${this.maxMapLength})`);\n    }\n\n    this.stack.pushMapState(size);\n  }\n\n  private pushArrayState(size: number) {\n    if (size > this.maxArrayLength) {\n      throw new DecodeError(`Max length exceeded: array length (${size}) > maxArrayLength (${this.maxArrayLength})`);\n    }\n\n    this.stack.pushArrayState(size);\n  }\n\n  private decodeString(byteLength: number, headerOffset: number): string | Uint8Array {\n    if (!this.rawStrings || this.stateIsMapKey()) {\n      return this.decodeUtf8String(byteLength, headerOffset);\n    }\n    return this.decodeBinary(byteLength, headerOffset);\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeUtf8String(byteLength: number, headerOffset: number): string {\n    if (byteLength > this.maxStrLength) {\n      throw new DecodeError(\n        `Max length exceeded: UTF-8 byte length (${byteLength}) > maxStrLength (${this.maxStrLength})`,\n      );\n    }\n\n    if (this.bytes.byteLength < this.pos + headerOffset + byteLength) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headerOffset;\n    let object: string;\n    if (this.stateIsMapKey() && this.keyDecoder?.canBeCached(byteLength)) {\n      object = this.keyDecoder.decode(this.bytes, offset, byteLength);\n    } else {\n      object = utf8Decode(this.bytes, offset, byteLength);\n    }\n    this.pos += headerOffset + byteLength;\n    return object;\n  }\n\n  private stateIsMapKey(): boolean {\n    if (this.stack.length > 0) {\n      const state = this.stack.top()!;\n      return state.type === STATE_MAP_KEY;\n    }\n    return false;\n  }\n\n  /**\n   * @throws {@link RangeError}\n   */\n  private decodeBinary(byteLength: number, headOffset: number): Uint8Array {\n    if (byteLength > this.maxBinLength) {\n      throw new DecodeError(`Max length exceeded: bin length (${byteLength}) > maxBinLength (${this.maxBinLength})`);\n    }\n\n    if (!this.hasRemaining(byteLength + headOffset)) {\n      throw MORE_DATA;\n    }\n\n    const offset = this.pos + headOffset;\n    const object = this.bytes.subarray(offset, offset + byteLength);\n    this.pos += headOffset + byteLength;\n    return object;\n  }\n\n  private decodeExtension(size: number, headOffset: number): unknown {\n    if (size > this.maxExtLength) {\n      throw new DecodeError(`Max length exceeded: ext length (${size}) > maxExtLength (${this.maxExtLength})`);\n    }\n\n    const extType = this.view.getInt8(this.pos + headOffset);\n    const data = this.decodeBinary(size, headOffset + 1 /* extType */);\n    return this.extensionCodec.decode(data, extType, this.context);\n  }\n\n  private lookU8() {\n    return this.view.getUint8(this.pos);\n  }\n\n  private lookU16() {\n    return this.view.getUint16(this.pos);\n  }\n\n  private lookU32() {\n    return this.view.getUint32(this.pos);\n  }\n\n  private readU8(): number {\n    const value = this.view.getUint8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readI8(): number {\n    const value = this.view.getInt8(this.pos);\n    this.pos++;\n    return value;\n  }\n\n  private readU16(): number {\n    const value = this.view.getUint16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readI16(): number {\n    const value = this.view.getInt16(this.pos);\n    this.pos += 2;\n    return value;\n  }\n\n  private readU32(): number {\n    const value = this.view.getUint32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readI32(): number {\n    const value = this.view.getInt32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readU64(): number {\n    const value = getUint64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64(): number {\n    const value = getInt64(this.view, this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readU64AsBigInt(): bigint {\n    const value = this.view.getBigUint64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readI64AsBigInt(): bigint {\n    const value = this.view.getBigInt64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n\n  private readF32() {\n    const value = this.view.getFloat32(this.pos);\n    this.pos += 4;\n    return value;\n  }\n\n  private readF64() {\n    const value = this.view.getFloat64(this.pos);\n    this.pos += 8;\n    return value;\n  }\n}\n", "import { Decoder } from \"./Decoder.ts\";\nimport type { DecoderOptions } from \"./Decoder.ts\";\nimport type { SplitUndefined } from \"./context.ts\";\n\n/**\n * It decodes a single MessagePack object in a buffer.\n *\n * This is a synchronous decoding function.\n * See other variants for asynchronous decoding: {@link decodeAsync}, {@link decodeMultiStream}, or {@link decodeArrayStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decode<ContextType = undefined>(\n  buffer: ArrayLike<number> | ArrayBufferView | ArrayBufferLike,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): unknown {\n  const decoder = new Decoder(options);\n  return decoder.decode(buffer);\n}\n\n/**\n * It decodes multiple MessagePack objects in a buffer.\n * This is corresponding to {@link decodeMultiStream}.\n *\n * @throws {@link RangeError} if the buffer is incomplete, including the case where the buffer is empty.\n * @throws {@link DecodeError} if the buffer contains invalid data.\n */\nexport function decodeMulti<ContextType = undefined>(\n  buffer: ArrayLike<number> | BufferSource,\n  options?: DecoderOptions<SplitUndefined<ContextType>>,\n): Generator<unknown, void, unknown> {\n  const decoder = new Decoder(options);\n  return decoder.decodeMulti(buffer);\n}\n", "var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\n\n// src/cache.ts\nimport { LRUCache } from \"lru-cache\";\nvar _Cache = class {\n  constructor() {\n  }\n  static getInstance(max = 1e4, maxAge = 1e3 * 60 * 10) {\n    if (!_Cache.instance) {\n      const options = {\n        max,\n        length: () => 1,\n        maxAge\n      };\n      _Cache.instance = new LRUCache(options);\n    }\n    return _Cache.instance;\n  }\n};\nvar Cache = _Cache;\n__publicField(Cache, \"instance\");\nvar cache_default = Cache;\n\n// src/indexedDB.ts\nvar IndexedDbManager = class {\n  DBname;\n  objectStoreName;\n  constructor(DBname, objectStoreName) {\n    this.DBname = DBname;\n    this.objectStoreName = objectStoreName;\n  }\n  static async create(DBname = \"clientVectorDB\", objectStoreName = \"ClientEmbeddingStore\", index = null) {\n    const instance = new IndexedDbManager(DBname, objectStoreName);\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(DBname);\n      let db;\n      request.onerror = (event) => {\n        console.error(\"IndexedDB error:\", event);\n        reject(new Error(\"Database initialization failed\"));\n      };\n      request.onsuccess = async () => {\n        db = request.result;\n        if (!db.objectStoreNames.contains(objectStoreName)) {\n          db.close();\n          await instance.createObjectStore(index);\n        }\n        db.close();\n        resolve(instance);\n      };\n    });\n  }\n  async createObjectStore(index = null) {\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DBname);\n      request.onsuccess = () => {\n        let db1 = request.result;\n        var version = db1.version;\n        db1.close();\n        const request_2 = indexedDB.open(this.DBname, version + 1);\n        request_2.onupgradeneeded = async () => {\n          let db2 = request_2.result;\n          if (!db2.objectStoreNames.contains(this.objectStoreName)) {\n            const objectStore = db2.createObjectStore(this.objectStoreName, {\n              autoIncrement: true\n            });\n            if (index) {\n              objectStore.createIndex(`by_${index}`, index, { unique: false });\n            }\n          }\n        };\n        request_2.onsuccess = async () => {\n          let db2 = request_2.result;\n          console.log(\"Object store creation successful\");\n          db2.close();\n          resolve();\n        };\n        request_2.onerror = (event) => {\n          console.error(\"Error creating object store:\", event);\n          reject(new Error(\"Error creating object store\"));\n        };\n      };\n      request.onerror = (event) => {\n        console.error(\"Error opening database:\", event);\n        reject(new Error(\"Error opening database\"));\n      };\n    });\n  }\n  async addToIndexedDB(objs) {\n    return new Promise(async (resolve, reject) => {\n      const request = indexedDB.open(this.DBname);\n      request.onsuccess = async () => {\n        let db = request.result;\n        const transaction = db.transaction([this.objectStoreName], \"readwrite\");\n        const objectStore = transaction.objectStore(this.objectStoreName);\n        if (!Array.isArray(objs)) {\n          objs = [objs];\n        }\n        objs.forEach((obj) => {\n          const request2 = objectStore.add(obj);\n          request2.onerror = (event) => {\n            console.error(\"Failed to add object\", event);\n            throw new Error(\"Failed to add object\");\n          };\n        });\n        transaction.oncomplete = () => {\n          resolve();\n        };\n        transaction.onerror = (event) => {\n          console.error(\"Failed to add object\", event);\n          reject(new Error(\"Failed to add object\"));\n        };\n        db.close();\n      };\n    });\n  }\n  async *dbGenerator() {\n    const objectStoreName = this.objectStoreName;\n    const dbOpenPromise = new Promise((resolve, reject) => {\n      const request = indexedDB.open(this.DBname);\n      request.onsuccess = () => {\n        resolve(request.result);\n      };\n      request.onerror = () => {\n        reject(new Error(\"Could not open DB\"));\n      };\n    });\n    try {\n      const db = await dbOpenPromise;\n      const transaction = db.transaction([objectStoreName], \"readonly\");\n      const objectStore = transaction.objectStore(objectStoreName);\n      const request = objectStore.openCursor();\n      let promiseResolver;\n      request.onsuccess = function(event) {\n        const cursor = event.target.result;\n        if (cursor) {\n          promiseResolver(cursor.value);\n          cursor.continue();\n        } else {\n          promiseResolver(null);\n        }\n      };\n      while (true) {\n        const promise = new Promise((resolve) => {\n          promiseResolver = resolve;\n        });\n        const value = await promise;\n        if (value === null)\n          break;\n        yield value;\n      }\n      db.close();\n    } catch (error) {\n      console.error(\"An error occurred:\", error);\n    }\n  }\n  async deleteIndexedDBObjectStoreFromDB(DBname, objectStoreName) {\n    return new Promise(async (resolve, reject) => {\n      const request = indexedDB.open(this.DBname);\n      request.onsuccess = async () => {\n        let db = request.result;\n        var version = db.version;\n        db.close();\n        const request_2 = indexedDB.open(db.name, version + 1);\n        request_2.onupgradeneeded = async () => {\n          let db2 = request_2.result;\n          if (db2.objectStoreNames.contains(objectStoreName)) {\n            db2.deleteObjectStore(objectStoreName);\n          } else {\n            console.error(\n              `Object store '${objectStoreName}' not found in database '${DBname}'`\n            );\n            reject(\n              new Error(\n                `Object store '${objectStoreName}' not found in database '${DBname}'`\n              )\n            );\n          }\n        };\n        request_2.onsuccess = () => {\n          let db2 = request_2.result;\n          console.log(\"Object store deletion successful\");\n          db2.close();\n          resolve();\n        };\n        request_2.onerror = (event) => {\n          console.error(\"Failed to delete object store\", event);\n          let db2 = request_2.result;\n          db2.close();\n          reject(new Error(\"Failed to delete object store\"));\n        };\n      };\n      request.onerror = (event) => {\n        console.error(\"Failed to open database\", event);\n        reject(new Error(\"Failed to open database\"));\n      };\n    });\n  }\n};\n\n// src/utils.ts\nvar cosineSimilarity = (vecA, vecB, precision = 6) => {\n  if (vecA.length !== vecB.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n  const dotProduct = vecA.reduce((sum, a, i) => {\n    const b = vecB[i];\n    return sum + a * (b !== void 0 ? b : 0);\n  }, 0);\n  const magnitudeA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));\n  const magnitudeB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));\n  if (magnitudeA === 0 || magnitudeB === 0) {\n    return 0;\n  }\n  return parseFloat(\n    (dotProduct / (magnitudeA * magnitudeB)).toFixed(precision)\n  );\n};\n\n// src/hnsw.ts\nimport { encode, decode } from \"@msgpack/msgpack\";\nvar PriorityQueue = class {\n  elements;\n  compareFn;\n  constructor(elements, compareFn) {\n    this.elements = elements;\n    this.compareFn = compareFn;\n    this.elements.sort(this.compareFn);\n  }\n  push(element) {\n    this.elements.push(element);\n    this.elements.sort(this.compareFn);\n  }\n  pop() {\n    return this.elements.shift() || null;\n  }\n  isEmpty() {\n    return this.elements.length === 0;\n  }\n};\nvar EuclideanDistance = (a, b) => {\n  if (a.length !== b.length) {\n    throw new Error(\"Vectors must have the same length\");\n  }\n  return Math.sqrt(\n    a.reduce((acc, val, i) => {\n      const bVal = b[i];\n      if (bVal === void 0)\n        throw new Error(\"b[i] is undefined\");\n      return acc + Math.pow(val - bVal, 2);\n    }, 0)\n  );\n};\nvar getInsertLayer = (L, mL) => {\n  return Math.min(-Math.floor(Math.log(Math.random()) * mL), L - 1);\n};\nvar _searchLayer = (graph, entry, query, ef) => {\n  if (entry < 0 || entry >= graph.length) {\n    throw new Error(`Invalid entry index: ${entry}`);\n  }\n  const graphEntry = graph[entry];\n  if (!graphEntry) {\n    throw new Error(`Graph entry at index ${entry} is undefined`);\n  }\n  const best = [\n    EuclideanDistance(graphEntry.vector, query),\n    entry\n  ];\n  const nns = [best];\n  const visited = /* @__PURE__ */ new Set([best[1]]);\n  const candidates = new PriorityQueue(\n    [best],\n    (a, b) => a[0] - b[0]\n  );\n  while (!candidates.isEmpty()) {\n    const current = candidates.pop();\n    const lastNnsElement = nns.length > 0 ? nns[nns.length - 1] : null;\n    if (!current || lastNnsElement && lastNnsElement[0] < current[0])\n      break;\n    const graphCurrent = graph[current[1]];\n    if (!graphCurrent)\n      continue;\n    for (const e of graphCurrent.connections) {\n      const graphE = graph[e];\n      if (!graphE)\n        continue;\n      const dist = EuclideanDistance(graphE.vector, query);\n      if (!visited.has(e)) {\n        visited.add(e);\n        const lastNn = nns[nns.length - 1];\n        if (!lastNn || dist < lastNn[0] || nns.length < ef) {\n          candidates.push([dist, e]);\n          nns.push([dist, e]);\n          nns.sort((a, b) => a[0] - b[0]);\n          if (nns.length > ef) {\n            nns.pop();\n          }\n        }\n      }\n    }\n  }\n  return nns;\n};\nvar ExperimentalHNSWIndex = class {\n  L;\n  mL;\n  efc;\n  index;\n  constructor(L = 5, mL = 0.62, efc = 10) {\n    this.L = L;\n    this.mL = mL;\n    this.efc = efc;\n    this.index = Array.from({ length: L }, () => []);\n  }\n  setIndex(index) {\n    this.index = index;\n  }\n  insert(vec) {\n    const l = getInsertLayer(this.L, this.mL);\n    let startV = 0;\n    for (let n = 0; n < this.L; n++) {\n      const graph = this.index[n];\n      if (graph?.length === 0) {\n        const nextLayer = this.index[n + 1];\n        const nextLayerLength = nextLayer ? nextLayer.length : null;\n        graph?.push({\n          vector: vec,\n          connections: [],\n          layerBelow: n < this.L - 1 ? nextLayerLength : null\n        });\n        continue;\n      }\n      if (n < l && graph) {\n        const searchLayerResult = _searchLayer(graph, startV, vec, 1);\n        startV = searchLayerResult && searchLayerResult[0] ? searchLayerResult[0][1] : startV;\n      } else if (graph) {\n        const nextLayer = this.index[n + 1];\n        const nextLayerLength = nextLayer ? nextLayer.length : null;\n        const node = {\n          vector: vec,\n          connections: [],\n          layerBelow: n < this.L - 1 ? nextLayerLength : null\n        };\n        const nns = _searchLayer(graph, startV, vec, this.efc);\n        for (const nn of nns) {\n          node.connections.push(nn[1]);\n          graph[nn[1]]?.connections.push(graph.length);\n        }\n        graph?.push(node);\n        const graphStartV = graph[startV];\n        if (graphStartV)\n          startV = graphStartV.layerBelow;\n      }\n    }\n  }\n  search(query, ef = 1) {\n    if (this.index && this.index[0] && this.index[0].length === 0) {\n      return [];\n    }\n    let bestV = 0;\n    for (const graph of this.index) {\n      const searchLayer = _searchLayer(graph, bestV, query, ef);\n      if (searchLayer && searchLayer[0]) {\n        bestV = searchLayer[0][1];\n        if (graph[bestV]?.layerBelow === null) {\n          return _searchLayer(graph, bestV, query, ef);\n        }\n        bestV = graph[bestV]?.layerBelow;\n      }\n    }\n    return [];\n  }\n  toJSON() {\n    return {\n      L: this.L,\n      mL: this.mL,\n      efc: this.efc,\n      index: this.index\n    };\n  }\n  static fromJSON(json) {\n    const hnsw = new ExperimentalHNSWIndex(json.L, json.mL, json.efc);\n    return hnsw;\n  }\n  toBinary() {\n    return encode({\n      L: this.L,\n      mL: this.mL,\n      efc: this.efc,\n      index: this.index\n    });\n  }\n  static fromBinary(binary) {\n    const data = decode(binary);\n    const hnsw = new ExperimentalHNSWIndex(data.L, data.mL, data.efc);\n    hnsw.setIndex(data.index);\n    return hnsw;\n  }\n};\n\n// src/index.ts\nvar DEFAULT_TOP_K = 3;\nvar cacheInstance = cache_default.getInstance();\nvar pipe;\nvar currentModel;\nvar initializeModel = async (model = \"Xenova/gte-small\") => {\n  if (model !== currentModel) {\n    const transformersModule = await import(\"@xenova/transformers\");\n    const pipeline = transformersModule.pipeline;\n    pipe = await pipeline(\"feature-extraction\", model);\n    currentModel = model;\n  }\n};\nvar getEmbedding = async (text, precision = 7, options = { pooling: \"mean\", normalize: false }, model = \"Xenova/gte-small\") => {\n  const cachedEmbedding = cacheInstance.get(text);\n  if (cachedEmbedding) {\n    return Promise.resolve(cachedEmbedding);\n  }\n  if (model !== currentModel) {\n    await initializeModel(model);\n  }\n  const output = await pipe(text, options);\n  const roundedOutput = Array.from(output.data).map(\n    (value) => parseFloat(value.toFixed(precision))\n  );\n  cacheInstance.set(text, roundedOutput);\n  return Array.from(roundedOutput);\n};\nvar EmbeddingIndex = class {\n  objects;\n  keys;\n  constructor(initialObjects) {\n    this.objects = [];\n    this.keys = [];\n    if (initialObjects && initialObjects.length > 0) {\n      initialObjects.forEach((obj) => this.validateAndAdd(obj));\n      if (initialObjects[0]) {\n        this.keys = Object.keys(initialObjects[0]);\n      }\n    }\n  }\n  findVectorIndex(filter) {\n    return this.objects.findIndex(\n      (object) => Object.keys(filter).every((key) => object[key] === filter[key])\n    );\n  }\n  validateAndAdd(obj) {\n    if (!Array.isArray(obj.embedding) || obj.embedding.some(isNaN)) {\n      throw new Error(\n        \"Object must have an embedding property of type number[]\"\n      );\n    }\n    if (this.keys.length === 0) {\n      this.keys = Object.keys(obj);\n    } else if (!this.keys.every((key) => key in obj)) {\n      throw new Error(\n        \"Object must have the same properties as the initial objects\"\n      );\n    }\n    this.objects.push(obj);\n  }\n  add(obj) {\n    this.validateAndAdd(obj);\n  }\n  // Method to update an existing vector in the index\n  update(filter, vector) {\n    const index = this.findVectorIndex(filter);\n    if (index === -1) {\n      throw new Error(\"Vector not found\");\n    }\n    this.validateAndAdd(vector);\n    this.objects[index] = vector;\n  }\n  // Method to remove a vector from the index\n  remove(filter) {\n    const index = this.findVectorIndex(filter);\n    if (index === -1) {\n      throw new Error(\"Vector not found\");\n    }\n    this.objects.splice(index, 1);\n  }\n  // Method to remove multiple vectors from the index\n  removeBatch(filters) {\n    filters.forEach((filter) => {\n      const index = this.findVectorIndex(filter);\n      if (index !== -1) {\n        this.objects.splice(index, 1);\n      }\n    });\n  }\n  // Method to retrieve a vector from the index\n  get(filter) {\n    const vector = this.objects[this.findVectorIndex(filter)];\n    return vector || null;\n  }\n  size() {\n    return this.objects.length;\n  }\n  clear() {\n    this.objects = [];\n  }\n  async search(queryEmbedding, options = {\n    topK: 3,\n    useStorage: \"none\",\n    storageOptions: {\n      indexedDBName: \"clientVectorDB\",\n      indexedDBObjectStoreName: \"ClientEmbeddingStore\"\n    }\n  }) {\n    const topK = options.topK || DEFAULT_TOP_K;\n    const filter = options.filter || {};\n    const useStorage = options.useStorage || \"none\";\n    if (useStorage === \"indexedDB\") {\n      const DBname = options.storageOptions?.indexedDBName || \"clientVectorDB\";\n      const objectStoreName = options.storageOptions?.indexedDBObjectStoreName || \"ClientEmbeddingStore\";\n      if (typeof indexedDB === \"undefined\") {\n        console.error(\"IndexedDB is not supported\");\n        throw new Error(\"IndexedDB is not supported\");\n      }\n      const results = await this.loadAndSearchFromIndexedDB(\n        DBname,\n        objectStoreName,\n        queryEmbedding,\n        topK,\n        filter\n      );\n      return results;\n    } else {\n      const similarities = this.objects.filter(\n        (object) => Object.keys(filter).every((key) => object[key] === filter[key])\n      ).map((obj) => ({\n        similarity: cosineSimilarity(queryEmbedding, obj.embedding),\n        object: obj\n      }));\n      return similarities.sort((a, b) => b.similarity - a.similarity).slice(0, topK);\n    }\n  }\n  printIndex() {\n    console.log(\"Index Content:\");\n    this.objects.forEach((obj, idx) => {\n      console.log(`Item ${idx + 1}:`, obj);\n    });\n  }\n  async saveIndex(storageType, options = {\n    DBName: \"clientVectorDB\",\n    objectStoreName: \"ClientEmbeddingStore\"\n  }) {\n    if (storageType === \"indexedDB\") {\n      await this.saveToIndexedDB(options.DBName, options.objectStoreName);\n    } else {\n      throw new Error(\n        `Unsupported storage type: ${storageType} \n Supported storage types: \"indexedDB\"`\n      );\n    }\n  }\n  async saveToIndexedDB(DBname = \"clientVectorDB\", objectStoreName = \"ClientEmbeddingStore\") {\n    if (typeof indexedDB === \"undefined\") {\n      console.error(\"IndexedDB is not defined\");\n      throw new Error(\"IndexedDB is not supported\");\n    }\n    if (!this.objects || this.objects.length === 0) {\n      throw new Error(\"Index is empty. Nothing to save\");\n    }\n    try {\n      const db = await IndexedDbManager.create(DBname, objectStoreName);\n      await db.addToIndexedDB(this.objects);\n      console.log(\n        `Index saved to database '${DBname}' object store '${objectStoreName}'`\n      );\n    } catch (error) {\n      console.error(\"Error saving index to database:\", error);\n      throw new Error(\"Error saving index to database\");\n    }\n  }\n  async loadAndSearchFromIndexedDB(DBname = \"clientVectorDB\", objectStoreName = \"ClientEmbeddingStore\", queryEmbedding, topK, filter) {\n    const db = await IndexedDbManager.create(DBname, objectStoreName);\n    const generator = db.dbGenerator();\n    const results = [];\n    for await (const record of generator) {\n      if (Object.keys(filter).every((key) => record[key] === filter[key])) {\n        const similarity = cosineSimilarity(queryEmbedding, record.embedding);\n        results.push({ similarity, object: record });\n      }\n    }\n    results.sort((a, b) => b.similarity - a.similarity);\n    return results.slice(0, topK);\n  }\n  async deleteIndexedDB(DBname = \"clientVectorDB\") {\n    if (typeof indexedDB === \"undefined\") {\n      console.error(\"IndexedDB is not defined\");\n      throw new Error(\"IndexedDB is not supported\");\n    }\n    return new Promise((resolve, reject) => {\n      const request = indexedDB.deleteDatabase(DBname);\n      request.onsuccess = () => {\n        console.log(`Database '${DBname}' deleted`);\n        resolve();\n      };\n      request.onerror = (event) => {\n        console.error(\"Failed to delete database\", event);\n        reject(new Error(\"Failed to delete database\"));\n      };\n    });\n  }\n  async deleteIndexedDBObjectStore(DBname = \"clientVectorDB\", objectStoreName = \"ClientEmbeddingStore\") {\n    const db = await IndexedDbManager.create(DBname, objectStoreName);\n    try {\n      await db.deleteIndexedDBObjectStoreFromDB(DBname, objectStoreName);\n      console.log(\n        `Object store '${objectStoreName}' deleted from database '${DBname}'`\n      );\n    } catch (error) {\n      console.error(\"Error deleting object store:\", error);\n      throw new Error(\"Error deleting object store\");\n    }\n  }\n  async getAllObjectsFromIndexedDB(DBname = \"clientVectorDB\", objectStoreName = \"ClientEmbeddingStore\") {\n    const db = await IndexedDbManager.create(DBname, objectStoreName);\n    const objects = [];\n    for await (const record of db.dbGenerator()) {\n      objects.push(record);\n    }\n    return objects;\n  }\n};\nexport {\n  EmbeddingIndex,\n  ExperimentalHNSWIndex,\n  getEmbedding,\n  initializeModel\n};\n"],
  "mappings": "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",
  "names": ["v", "bf", "encode", "decode", "size"]
}
